## 用户建立连接后，权限是否能被修改？
用户的权限校验，是在连接建立时进行的。   
对于已建立连接的用户，是不生效的。

---

## mysql 过多长连接导致内存过大？
mysql 在执行过程中，临时使用的内存是管理在连接对象中的。这些资源只有在连接断开时才会被释放。    
如果长连接积累过多，会导致内存占用过多，最终 OOM，从现象看就是 mysql 异常重启了。

针对这种问题，我们可以考虑两种方案：   
1、定期断开长连接，可以设置最大存活时间。     
2、如果是 mysql5.7 及以上版本，可以执行 mysql_reset_connection 来重置和初始化连接资源。    

---

## 什么是事务？
我们知道的比较多的就是数据库事务。   
他是对一批待执行命令的简称，这批命令要么全部执行，要么全部不执行。    

---

## MyISAM 和 InnoDB 对比如何？
1、InnoDB 支持事务，而 MyISAM 不支持事务。特别是再数据库全量备份时，如果不支持事务，那么数据库不得不上全局锁以保证数据正确备份。     
2、InnoDB 基于 WAL 机制，提供 crash-safe 保障数据不丢失    
3、InnoDB 支持行锁，而 MyISAM 不支持。所以在并发支持上 InnoDB 更佳。

---

## 为什么不建议使用长事务？
数据库由于多版本并发控制，在事务执行期间，会生成版本视图。当事务存在的时间越久，那么系统中就会存在越多的历史视图。  
因为事务是需要可回滚，在长事务结束前都不能释放这些历史记录，这回导致占用大量的存储空间。

---

## 如何减少数据库回表？
以 B+树 索引为例，存在两类索引，一种时主键索引，一种是普通索引。   
主键索引的叶子节点存储的是整行数据，而普通索引叶子节点存储的是主键索引的值。

而回表就是查询普通索引获取主键索引的值，然后再通过主键值去主键索引再次搜索的过程。  
回表会大大降低数据库的性能。

常见的减少数据库回表的措施有：   
1、覆盖索引：普通索引中的信息已经满足查询条件时，则不会再回表查询。常见的有查询主键ID，或者联合索引中存在待查询字段。         
2、索引下推：索引查询时会有心啊过滤掉不满足条件的索引，以此减少回表次数。   

---

## 如何对一个热点表进行 alter？
因为读表时会默认加上 MDL 读锁，而 alter 会修改表结构，会默认加上 MDL 写锁。他们二者冲突。在热点表上更有可能造成事故。    
一般建议对 alter 加上等待时间，在等待时间里如何能拿到最好，拿不到也不会阻塞其他线程。

---

## 热点行更新导致的性能问题？
针对热点行更新导致的性能问题，一般是死锁检测导致的。一般建议是降低并发度。

---

## 事务启动时视图是如何生成的？
事务启动时会申请唯一的事务ID，这是实现MVCC多版本管理的关键。

以可重复读事务隔离级别为例。在数据库中，每一行数据都存在多个版本。   
每次事务更新数据时，也都会生成一个新的数据版本，并将当前事务ID作为版本号。   
在同一行中，多个事务之间形成一条链式的关系。

---

## mysql 为什么会选错索引
sql 执行时会经过优化器，优化器的目的就是选择合适的查询方式，包括选择索引。   
大部分场景下索引都可以选择正确，某些场景可能会选错：  
1、统计信息未更新。      
2、两个索引之间，存在对另一个索引排序操作。   

万能的方式是使用强制索引，但是不友好。   
针对第一种的方式，可以选择重新统计表信息。这样可以避免数据库选错索引。   
针对第二种方式，可以去除排序，或者对两个索引都加入排序，可以避免索引选择过程中权重的偏移。

---

## mysql 为什么会抖一下？
基于 WAL 技术，数据库可以将随机写转化为顺序写，从而提高性能。   
但是也引入了脏页的概念。即内存数据与磁盘数据不一致时，我们称之为脏页。   
mysql 抖动往往和刷脏页有关：  
1、redo log写满了，需要强制刷新。   
2、内存满了，即需要需要申请新的内存页时发现内存不足，需要刷新脏页数据从而释放内存。   

---

## 删除数据，表大小没变？
InnoDB 的数据是按照页存储的，如果删除某一行数据，该行数据所占据的空间不会被释放，而是留着以备复用。   
所以频繁的插入和删除数据，是会造成页空洞的。这也是删除数据后，表大小没变的原因，因为考虑到了复用。   

解决问题的方法就是重建表。索引也是一样的道理。

---

## 为什么 count(*) 不存储总行数？
因为存在事务和隔离级别的概念，在 count(*) 过程中值不一定是可靠的。

---

## count(id) 和 count(*) 区别？
count(id) 查询时会返回 id 字段的值。   
count(*) 查询时有特殊优化，不会返回任何值，仅作统计记录。

---

## count 慢怎么处理？
count 慢一般是数据量过大。可以选择表分区，或者预先统计好表行数，避免临时计算。

---

## mysql 不会使用索引？
1、函数操作。对索引字段使用函数操作。       
2、隐式类型转化。当条件与字段类型不一致时，会隐式增加类型转化函数。   
3、隐式编码转化。当两种表编码不同时，会隐式增加编码转化函数。    

---

## mysql排序如何执行？
mysql 会分配一块内存用于排序，叫 sort_buffer。   
通常排序有全字段排序和rowid排序。    

全字段排序通常用于查询字段较少的场景。当查询字段较多，会有大量数据占据 sort_buffer 资源空间。   
此时使用 rowid 排序，仅保留排序字段与主键，排序好后再回表取出字段。

```sql
SELECT * FROM table WHERE name = 'cza' ORDER BY name;
```
当 name 字段存在索引时，我们来看下当前语句的执行流程：  
1、初始化 sort_buffer，确定需要放入的字段。   
2、从索引中找到第一个满足条件的主键ID。   
3、回表查询所在行，取出对应的字段，存入 sort_buffer 中。   
4、从索引中获取下一个记录，直至全部查询完毕。   
5、对 sort_buffer 中的数据按照字段 name 做快速排序。

---
## 如何正确的显示随机消息？
随机可以使用 `order by rand()`。但是当数据量增大时，排序会造成较大的资源损耗。   
随机数据建议自己先确定随机主键，然后根据主键进行查询消息。

---

## 为什么查询一条数据也很慢？
1、没有使用索引。  
2、数据被锁住。MDL锁，行锁。      
3、正在刷脏页。    
4、长事务积累导致回滚日志过长。  
  
---
  
## 什么时幻读？
幻读，一般指在可重复读隔离级别。事务连续两次读取同一个范围时，后一次查询看到了前一次查询没有看到的行。   
一般指新增的行。  

在可重复读隔离级别下一般不会出现这个问题，但是当我们使用当前读（for update）时，是可以获取到最新数据的。    

行锁没有办法阻止幻读，因为即使把所有的行上锁，新增行却不会受到影响。   
所以需要引入间隙锁。但间隙锁的引入，会降低性能。

---

## 如何优化mysql性能？
查询方面：   
1、索引没有设计好  
2、sql 没有写好   
3、mysql 选错了索引

---

## 分区和分表？
分区：就是把一张表的数据分成 N 个区块，在逻辑上还是一张表，但是底层已经被分成了 N 个物理块。   
分表：就是把一张表按照一定的规则，将数据拆分成 N 个独立的实体表中。常用的就是哈希，将数据散射到不同的表中。    

分区的方法：   
1、RANGE 分区：如果某字段具有连续属性，可以将其按照一定范围进行分区。     
2、LIST 分区：  
3、HASH 分区：  
4、KEY 分区：  

什么时候考虑分区？    
当数据量过大，已经影响到了正常 sql 的执行性能，且对数据的操作往往只涉及一部分数据，而不是所有数据时。可以考虑分区。  
分区可以使单表存储更多数据，表分区数据可以分布在不同的物理设备上，从而高效的利用多个硬件设备。   
加快查询效率。当可以通过分区过滤数据时，可以大大减少待匹配的数据源。   
分区表也更加容易维护，当需要清除大量数据时，可以直接清除分区。

什么时候考虑分表？
当数据量过大，影响 sql 执行性能，且存在频繁的增删改、索引分裂等影响性能时，可以考虑分表。   
分表后单表的并发能力提高了，切单表数据量减少，维护更加快速。
