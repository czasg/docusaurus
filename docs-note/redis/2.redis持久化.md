---
title: redis 持久化
sidebar_label: redis持久化
---

redis 属于内存数据库，一旦服务停止，内存中的数据就会丢失。

但如果是作为缓存使用，数据丢失在一定程度上是可以接受的，只需要及时恢复数据即可。常见的恢复方法有：   
1、将数据从数据库再写入 redis。      
2、依赖 redis 持久化机制恢复数据。     

本文主要介绍 redis 的持久化机制，目前，redis 的持久化机制主要有 AOF 日志和 RDB 快照。


## AOF（Append Only File）
日志的主要作用就是记录信息。
在数据库中，我们熟悉的**写前日志**（WAL - write ahead log），就是在数据写入前，会先把这次修改的数据记录到日志中，以便故障时恢复。   

在 redis 中正好相反，AOF 是写后日志，即先执行命名将数据写入内存，再记录日志。     
因为 redis 是基于内存操作的，他的特点就是快，如果强行再操作前加入磁盘IO操作，那毫无疑问性能会大打折扣。    
所以 redis 的 AOF 日志采用的是写后操作，并不会阻塞当前写操作。

了解 AOF 之后，说下 AOF 存在的两个缺陷：   
1、如果执行完一个指令后，系统就宕机了，那这次请求将无法恢复。   
2、AOF 采用的写后日志，虽然可以避免阻塞当前请求，但是可能会对后面的请求造成影响。特别是当磁盘性能存在压力时，会导致阻塞。    

第一个缺陷是硬伤，如果需要做到绝对恢复，应该将数据保存到数据库，这样可以再次写入到 redis。     
第二个缺陷，有不同的写回策略，包括：    
* **Always**：同步写回。每个写命令执行完成，立马将日志写入磁盘。
* **Everysec**：每秒写回。每次执行命名，只是将日志写到 AOF 文件内存缓冲区，每隔一秒把缓冲区中的内存写回磁盘。
* **No**：由操作系统控制写回。每次执行完指令后就不管了，由操作系统决定何时将缓冲区内存写回磁盘。

AOF 用于存储具体的执行命令，但是当系统运行时间足够长，可能积累的 AOF 文件就越来越大了，这样恢复数据的时候，也会十分的耗时。     
为了解决这个问题，redis 支持 AOF 重写，重写的意思就是将 AOF 重新进行一遍整理、合并。这样可以精简 AOF 文件。

#### AOF 重写机制
在 redis 中，对一个键进行了 N 次修改，那其实最终只有最后一次修改才有保存的意义。   
这样经过 AOF 重写之后，针对这个键的日志，将仅保留最后一条。

在 redis 这种"单线程"模型中，阻塞是非常致命的。所以会设计各种机制来避免直接阻塞 redis 操作。    
AOF 重写过程中，会创建一个线程，执行重写过程，期间新来的数据，会被记录到 AOF 重写缓冲区。
当重写完成后，会再将缓冲区的数据写入到新的AOF文件中。


## RDB（Redis DataBase）
我们知道 AOF 日志机制，他会记录具体的执行指令，
那么恢复数据时就会有一个回放指令的行为，当数据量特别大时，恢复是需要很久的。
所以 redis 还支持另一种持久化，**RDB 内存快照**，可以直接记录具体的数据，以便直接恢复使用。

和 AOF 相比，RDB 记录的是某一时刻的全量数据。redis 支持两种全量快照：   
1、`save`，在主线程中执行，会导致 redis 阻塞。  
2、`bgsave`，创建子进程执行全量快照，避免 redis 阻塞。  


在 save 快照生成期间，redis 处于阻塞状态，无法提供服务，所以缓存数据一致性可以得到保障。即全量快照生成的 RDB 数据一定和内存中数据一致。   
在 bgsave 快照生成期间，依赖操作系统提供的**写时复制技术**（Copy-On-Write, COW），不会阻塞主线程。    
即在快照生成期间，如果是读请求，那么完全不会有冲突。
但如果是写请求，数据就会被拷贝一份，此时 redis 主线程可以直接修改数据，而 bgsave 线程则读取副本数据，并将其写入 RDB 文件。

```text title="redis save 常见配置"
save 900 1
save 300 10
save 60 10000
```
1、在 900秒 后有 1次 更新，就进行持久化操作   
2、在 300秒 后有 10次 更新，就进行持久化操作   
3、在 60秒 后有 10000次 更新，就进行持久化操作    

