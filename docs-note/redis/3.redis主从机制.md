---
title: redis 主从机制
sidebar_label: redis主从机制
---

redis 作为主流的内存数据库，除了提供高性能读写外，还保障了服务的高可靠。这里的高可靠大致包含两个目标：    
1、保障数据尽量不丢失。     
2、保障服务尽量少中断。     

针对第一个高可靠目标，我们可以通过 AOF 日志和 RDB 文件快照等持久化机制实现。     
针对第二个高可靠目标，最常见的解决方案就是多副本冗余。即将一份数据同时保存在多个 redis 实例中。
这样即使某个实例异常，另一个冗余实例也可以快速提供服务。

多副本机制的核心点，就是数据的同步机制。   
本文主要介绍 redis 中的主从同步机制。

## 主从同步 - 读写分离
redis 提供了主从同步机制用于保障主从节点之间的数据一致性。而且主从库之间采用的是**读写分离**的方式，也就是说在处理读操作和写操作时是有区别的：
* 读操作：主库、从库均可执行。 
* 写操作：只能主库可执行，否则会产生歧义。主库接受写操作后，再同步给从节点。     

![](./static/3.1.png)

## 主从同步 - 首次同步
在 redis 中搭建主从比较简单，仅需要启动时配置 `replicaof` 指定主库即可：
```text
replicaof localhost 6379
```
主从关系建立后，会按照三个阶段实现完成数据的第一次同步。

#### 1、第一阶段
从库和主库建立连接，并告诉主库即将进行同步。主库确认回复后，主从之间就可以开始同步了。

1、从库和主库建立连接  
2、从库给主库发送 **psync（包含了主库的 runID 和从库的 offset 两个参数）** 命令，表示要进行数据同步  
* runID：redis 启动时随机生成的 ID，用于唯一标记此实例。第一次同步时，由于不知道主库，故传递为 `?`
* offset：第一次同步为 -1，表示需要全量同步
3、主库接收到 psync 指令，然后返回 `FULLRESYNC` 响应，该响应中包含主库的 runID 和主库的复制进度 offset。从库会记录这两个参数。

#### 2、第二阶段
主库生成全量快照，并同步给从库。从库先清空内存，然后接受数据并加载进内存。

在主从同步期间，主库是非阻塞的，可以正常接受写请求。所以为了保证主从数据一致性，
在主从同步期间，所有的写操作，会被记录到 `replication buffer` 中。

#### 3、第三阶段
将 `replication buffer` 中的写操作同步给从库。


## 主从同步 - 联级模式
redis 第一次主从同步时，需要生成全量快照，并传输快照文件给从库。这其实是一个比较消耗资源的过程。  
当从库过多时，会对主库造成较大的负担。为了解决这类问题，redis 支持 主-从-从 的联级模式。

即新的实例，不在直连主库，而是选择一个从库实例，作为主库连接。通过这种方式将压力分散到从库中。

![](./static/3.2.png)


## 主从同步 - 增量同步
在主从同步过程中，网络异常时不可避免。那么当因为类似网络问题导致的主从断连，回发生什么呢？

在 redis 2.8 之前，主库和从库之间出现网络闪断后，从库会申请进行一次全量复制。开销非常大。   
在 redis 2.8 之后，主从之间采用增量更新的方式进行同步。

核心是 `repl_backlog_buffer` 环形缓冲区，主库记录写入的位置，从库记录读取的位置。    
当断连发生后，主库会将写操作记录到 `replication buffer` 缓冲区中，并同时写入到 `repl_backlog_buffer` 环形缓冲区。   
接受写操作后，主库记录位置开始偏移 `master_repl_offset`，从库位置则不变 `slave_repl_offset`。

主从恢复之后，从库将 offset 传递给主库，主库就知道从库待更新的数据是什么了。  
数据同步时，将 `master_repl_offset` 和 `slave_repl_offset` 之间的数据传递给从库即可。

由于 `repl_backlog_buffer` 是一个环形缓冲区，当缓冲区写满之后，主库会覆盖继续写入，此时从库若断连时间过久，导致更新数据被覆盖了，那么就会进行全量同步。
为了避免这种情况，可以适当调整 `repl_backlog_size` 参数。


