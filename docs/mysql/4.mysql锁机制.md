---
title: mysql 锁机制
sidebar_label: mysql锁机制
---

锁的初衷是为了解决并发问题。特别是当并发访问公共资源时，更需要合理的控制资源的访问规则。   
根据加锁的范围，mysql 中大致存在三类锁机制：全局锁、表锁、行锁。

## 全局锁
全局锁是对整个数据库实例加锁。      
mysql 提供了一种加全局锁的方式：`flush tables with read lock`（FTWRL）。   
使用全局锁后，数据库实例将处于只读的状态。

现在使用全局锁的场景比较少了，以前使用全局锁最多的场景就是做数据库的全量备份。   
因为数据库引擎 MyISAM 不支持事务，所以再做全量备份时，为了保障数据安全，需要加上全局锁。   
而数据库引擎 InnoDB 支持事务，在可重复读的隔离级别下，可以安全的执行全量备份。

除了全局锁，还有一种方式可以使得数据库全局只读。那就是修改全局配置：`set global readonly=true`。   
通过这种方式也可以实现数据库只读。但是除非特殊场景，不然一般不建议这样操作，
因为在某些场景下，readonly 有特殊含义，可能会被用作主库从库的判断。   

## 表锁
mysql 中的表锁有两种：一种是**普通表锁**，另一种是**元数据锁**（meta data lock，MDL）。

申请普通表锁的方式是：`lock table xxx read/write`。比如：`lock table test1 read, test2 write`。   
这时，当前可以对 test1 表进行读操作，对 test2 表进行读写操作。而其他用户，则只能对 test1 进行读操作，而无法对 test2 进行操作。

MDL 锁不需要主动申请，在访问一个表的时候，会自动加上 MDL 读锁。在对表的结构做出修改时，会自动加上 MDL 写锁。   
因为读写锁冲突，所以当对一个访问频率很高的表执行 alter 操作时一件十分危险的事情。   

## 行锁
行锁是引擎层实现的，但不是所有引擎都支持行锁，InnoDB 支持而 MyISAM 不支持，所以在并发执行度上 InnoDB 更佳。  

```sql
BEGIN;
UPDATE table SET k=k+1 WHERE ID = 1;
UPDATE table SET k=k+1 WHERE ID = 2;
COMMIT; 
```
以 InnoDB 为例，在执行上面 sql 时：  
1、开启事务  
2、给 ID=1 的行加锁  
3、给 ID=2 的行加锁  
4、提交事务，释放两个行锁   

期间，如果有其他事务，要修改同一行时，会被阻塞直至行锁被释放。   
在一个事务中，行锁会一致存在与整个事务，不是不需要了就立即释放，而是需要等到事务结束后才释放，
所以在事务中，我们可以将最可能造成锁冲突的条件放置最后。   


## 死锁
当并发系统中，不同线程出现循环的额资源依赖时，就可能造成死锁。如：
1、事务A 对 ID=1 的行上锁   
2、事务B 对 ID=2 的行上锁  
3、事务A 再对 ID=2 的行申请锁时，发现已经上锁，需要等待   
4、事务B 再对 ID=1 的行申请锁时，发现已经上锁，需要等待   
5、此时两个事务都无法执行，出现死锁  

当出现死锁后，一般有两种解决方法：  
1、第一种是不处理，等待超时。InnoDB 可以通过 innodb_lock_wait_timeout 参数配置超时。   
2、第二种是发起死锁检测。即发生死锁时，主动回滚死锁链中的某一个事务，让其他事务继续执行。   

## 死锁检测
死锁检测的逻辑，是每当事务被锁住后，检测它所依赖的线程有没有被别人锁住。以此循环最后判断是否出现死锁。    
所以死锁检测是一个比较有效的方法，也是一个性能很低的方法。 

如果数据库并发度很高，且经常发生死锁。这会导致大量资源都被投入死锁检测。我们能看到的现象就是，数据库 cpu 满载，但事务完成数量却很少。   
这是典型的热点行更新导致的性能问题。问题的核心是死锁检测耗费大量 cpu 资源。   
解决这个问题的最好方法其实就是控制并发度。   



