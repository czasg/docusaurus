---
title: 后端基础
sidebar_label: 后端基础
slug: backend
description: 后端基础
---

### 如何理解面向对象编程与函数式编程
面向对象编程（Object-Oriented Programming，OOP）和函数式编程（Functional Programming，FP）是两种不同的编程范式，
它们有不同的思想和设计原则。下面是对它们的简要理解：

#### 面向对象编程（OOP）：

1. **对象：** OOP 是以对象为核心的编程范式。对象是数据和行为的封装单元，包括属性（数据）和方法（行为）。
2. **封装：** 封装允许将数据和相关的操作封装在一起，隐藏对象内部的实现细节，只暴露必要的接口。
3. **继承：** 继承允许一个对象（子类）继承另一个对象（父类）的属性和方法，促使代码重用和扩展。
4. **多态：** 多态允许不同的对象对相同的方法作出不同的响应。这提高了灵活性和可扩展性。
5. **类和实例：** 类是对象的模板，实例是类的具体实现。通过创建类，可以生成多个相似但独立的实例。

#### 函数式编程（FP）：

1. **函数为一等公民：** 函数在函数式编程中被视为一等公民，可以作为参数传递给其他函数，也可以作为返回值返回。
2. **纯函数：** 纯函数是没有副作用的函数，其输出仅取决于输入，不会修改外部状态。这有助于代码的可维护性和可测试性。
3. **不可变性：** 数据一旦创建就不能被修改，而是通过创建新的数据来表示变化。这有助于避免共享状态引起的问题。
4. **递归：** 函数式编程通常使用递归来替代循环，因为它符合纯函数的概念，也更容易推理和理解。
5. **高阶函数：** 函数可以接受其他函数作为参数或返回函数，这种特性称为高阶函数。
6. **声明式编程：** FP 更倾向于声明式而非命令式的编程风格，更关注“做什么”而不是“怎么做”。

#### 对比：

- **状态管理：** OOP 通常涉及状态管理，而 FP 偏向无状态的函数。这使得 FP 更容易推理和测试。
- **可变性：** OOP 中对象的状态可以改变，而 FP 倾向于不可变性，通过创建新的数据来表示状态的变化。
- **编程风格：** OOP 更注重数据和行为的封装，而 FP 更注重函数和数据的组合。
- **并发性：** FP 的纯函数和不可变性使得在并发环境中更容易管理状态。


### 请介绍下 session 和 token

`Session` 和 `Token` 是计算机领域中常用的两个概念，它们在不同上下文中有不同的含义。下面分别介绍它们在网络应用和身份验证领域的常见用法：

#### Session（会话）：

在网络应用中，`Session` 通常指的是用户与服务器之间的一次会话，它可以用于跟踪用户的状态和存储用户相关的信息。
一般而言，`Session` 的工作方式如下：

1. **创建会话：** 当用户首次访问一个网站时，服务器会为该用户创建一个唯一的会话标识，通常以一个会话 ID 表示。
2. **存储信息：** 在用户与服务器的交互过程中，可以将用户的相关信息（如登录状态、购物车内容等）存储在会话中。
3. **持久性：** 会话通常具有一定的持久性，可以在用户多次请求之间保持状态。这可以通过在用户的浏览器中存储一个包含会话 ID 的 Cookie 来实现。
4. **销毁会话：** 会话通常在用户关闭浏览器或一定时间内不活动时被销毁，以释放资源并清理状态。

在服务器端，会话信息可以存储在内存、数据库或其他持久化存储中。

#### Token（令牌）：

在身份验证和授权领域，`Token` 通常指的是一串字符，用于表示用户的身份或者授予用户访问资源的权限。
常见的使用场景包括 OAuth、JWT（JSON Web Token）等。

1. **身份验证：** 用户在登录后，服务器可以生成一个包含用户身份信息的令牌，并将其返回给客户端。客户端在后续请求中通过携带该令牌来证明其身份。
2. **授权：** 令牌也可以包含授权信息，指示客户端具有访问某些资源的权限。
3. **无状态性：** 令牌的无状态性使得服务器不需要存储用户的身份信息，从而提高了系统的可伸缩性。
4. **JWT：** JSON Web Token 是一种常见的令牌标准，它以 JSON 格式编码信息，并使用签名或加密来验证令牌的真实性。
   - "Bearer" 是一种认证方案的类型

总的来说，`Session` 主要用于在服务器和客户端之间跟踪用户状态和存储用户信息，而 `Token` 则用于在身份验证和授权过程中传递身份信息和访问权限。这两个概念在实际应用中也可能相互结合使用。

### HTTP Authorization
HTTP Authorization 头用于在 HTTP 请求中传递客户端的身份验证信息。它的组成方式为：`Authorization: <scheme> <credentials>`。
也就是由认证方案的类型和认证信息组成。

常见的认证方案类型：

1. **Basic Authentication:**
    - 使用用户名和密码的 Base64 编码字符串。
    - 格式：`Authorization: Basic <base64-encoded-credentials>`
    - 示例：`Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l`
2. **Bearer Token (OAuth 2.0):**
    - 与 OAuth 相关，用于传递访问令牌。
    - 格式：`Authorization: Bearer <access-token>`
    - 示例：`Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`

### HTTP状态码
- 200 OK
- 201 Created: 表示资源已创建，常用于POST响应中
- 204 No Content
- 206 Partial Content: 表示处理了部分GET请求，常用于支持断点续传
- 301 Moved Permanently
- 302 Found
- 304 Not Modified
- 400 Bad Request
- 401 Unauthorized
- 403 Forbidden
- 404 Not Found
- 500 Internal Server Error
- 501 Not Implemented
- 502 Bad Gateway

### 设计模式


