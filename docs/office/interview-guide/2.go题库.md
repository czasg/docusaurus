---
title: Go 题库
sidebar_label: Go 题库
slug: golang
description: 收录Go常见面试题库
---

## 基础概念

### 如何理解协程
协程（Goroutine）是用户态轻量级线程。相比于线程，它的调度完全在用户态，所以会大大减少系统调度的开销。

在Go中，只需要使用 `go` 关键字就可以快速启动一个协程。

一个 Goroutine 会以一个很小的栈启动，大概只需要花费 2~4KB 的内存，因此可以轻易实现成千上万个 Goroutine 同时启动。

---

### Go解析Tag原理？反射原理？
解析 Tag 通过反射。

反射是在程序运行时检查对象属性的一种机制。包括对属性的查看、赋值等。像标签也是属性的一种。
在Go中，我们可以通过reflect库实现反射操作。

---

### 什么是枚举
iota 是一个常量生成器，通常用于定义枚举值。默认从0开始
```go showLineNumbers
const (
	B = 1 << (10 * iota)
	KiB 
	MiB
	GiB
	TiB
	PiB
	EiB
)
```

---

### 介绍下 rune 类型
rune 类型是 int32 的别名，通常用于处理 unicode 字符集 和 utf8 字符编码。

- ascii 仅支持表示英文和特殊字符
- unicode 是一个全量的字符集
- utf8 是一种编码方案，而且是一种可变长度的编码

字符串在 Go 中的底层数据存储是基于 []byte，当和普通的字节切片不同，Go 提供了语言级别的保护。
确保了 string 的不可变类型和正确的 UTF-8 编码。

---

### var、new、make的区别
在 Go 语言中，`var`、`new` 和 `make` 有不同的用途，用于声明和初始化不同类型的变量。下面是它们的主要区别：

1. **`var`：**用于声明变量。
    - 对于基本数据类型（int、float64、bool 等），`var` 会声明变量并初始化为零值（zero value）。
    - 对于复合数据类型（如数组、结构体、map、slice 等），`var` 会声明变量但不进行初始化，复合数据类型会被初始化为 nil 或零值。

   ```go
   var x int         // x 是 int 类型，初始值为 0
   var y string      // y 是 string 类型，初始值为空字符串 ""
   var z []int       // z 是切片类型，初始值为 nil
   ```

2. **`new`：**用于创建指定类型的新实例，并返回该实例的指针。
    - 对于基本数据类型，`new` 返回指向零值的指针。
    - 对于复合数据类型，`new` 返回指向零值或 nil 的指针。

   ```go
   px := new(int)    // px 是指向 int 的指针，指向的值为 0
   ps := new(string) // ps 是指向 string 的指针，指向的值为空字符串 ""
   pz := new([]int)  // pz 是指向切片的指针，指向的值为 nil
   ```

3. **`make`：**用于创建并初始化引用类型的实例，如切片、映射、通道等。
    - `make` 返回引用类型的实例，而不是指针。
    - `make` 仅用于创建 slice、map 和 channel，不能用于其他类型。
      - `make(map[string]string, 10)`：初始容量为10
      - `make([]string, 10, 20)`：长度为10，容量为20
      - `make(chan string, 10)`：容量为10

   ```go
   s := make([]int, 5)      // s 是切片，长度为 5，容量为 5
   m := make(map[string]int) // m 是 map，已初始化并可用
   c := make(chan int)       // c 是 channel，已初始化并可用
   ```

总的来说：
- `var` 用于声明变量，不进行初始化，零值或 nil 值取决于变量类型。
- `new` 用于创建指定类型的新实例，并返回指针，零值或 nil 值取决于变量类型。
- `make` 用于创建并初始化引用类型的实例，返回实例本身。

---

### 值传递和引用传递
1. **值传递（Pass by Value）：**
    - 在值传递中，函数接收的是实际参数的副本。
    - 当在函数内部修改参数的值时，不会影响到原始数据。

2. **引用传递（Pass by Reference）：**
    - 在引用传递中，函数接收的是实际参数的地址（指针）。
    - 当在函数内部通过指针修改参数指向的值时，会影响到原始数据。
    - 切片、映射和通道等引用类型在函数调用时通常采用引用传递。

Go语言中没有显式的引用传递。即使使用了引用类型，仍然是通过值传递传递的指针。

---

### GC机制

GC是一种自动管理程序内存的机制。主要作用就是释放不在使用的对象，从而使得内存可以重复利用。

不同编程语言，GC机制的实现方式往往不同，但是他们的目的和难点基本都是一样的。
目的就是释放不再使用的对象，难点就是如何减少对业务进程的影响。在Go中主要就是STW会对业务进程造成较大的影响。

Go的GC机制使用的就是三色标记法-清除。他把一次完整的GC分为标记和清除两个阶段。三色表示的就是黑白灰三种颜色。
其中，白色表示未知对象，灰色表示该对象存活，但子对象未知。黑色表示该对象确认存活。

具体Go版本的GC机制我记得不是很清楚，但是大致趋势我记得：
- 早期是并发的标记和STW的清除，由于STW对性能影响过大。
- 因此下一个版本引入了增量GC，其实就是把一次完成的GC拆分成了多个阶段实现，
从而减少STW时间，使程序更加平稳。但STW问题并没有解决。
- 然后是1.5版本引入了并发的标记和并发的清除，显著的减少了STW时间。
- 1.8版本对并发标记清除做了整合，进一步优化了STW问题。

#### Go 1.1及之前版本：

- **标记阶段**：引入了并发标记，使得标记过程可以与程序的执行并发进行。这意味着垃圾回收器可以在不暂停整个程序的情况下标记不再使用的对象。

- **清理阶段**：清理阶段是STW的，整个程序的执行都会被暂停。在这个阶段，垃圾回收器会扫描堆上的对象，清理并回收不再使用的对象。

#### Go 1.2及之后版本：

- **增量垃圾回收**：引入了增量垃圾回收，将标记和清理过程分解成多个小步骤，每个步骤都在程序执行中交替进行。这样可以减小STW的时间，提高程序的响应性。

- **读写屏障**：引入了读写屏障，用于确保在并发标记的过程中，对对象的读取和写入是安全的。

#### Go 1.5及之后版本：

- **并发垃圾回收**：引入了并发垃圾回收，标记和清理过程都可以与业务进程并发执行。这意味着整个垃圾回收过程都不再需要STW，减小了对程序执行的干扰。

- **GOGC参数**：引入了GOGC参数，通过调整这个参数，开发者可以影响垃圾回收的频率，以更好地适应不同类型的应用程序。

- **并发标记和清理**：标记和清理过程的并发执行大大提高了垃圾回收的性能和响应性。

#### Go 1.8及之后版本：

- **整合并发标记和清理**：引入了基于并发标记-清除和并发清理的垃圾回收器。标记和清理的整个过程都是并发执行的，没有明显的STW阶段。

- **性能提升**：通过整体性能的提升，进一步降低了对程序执行的影响。

---

### GMP模型
Go 的 GMP 模型是**一种用于实现并发的模型**。它包含三种不同的角色：

- G（Goroutine）：Goroutine 是 Go 语言中的轻量级线程，也是此并发模型中的最小调度单位。
- M（Machine）：Machine 是 Go 语言中的执行线程。它负责运行 Goroutine。
- P（Processor）：Processor 是 Go 语言中的处理器。它负责管理一组 M 并将 G 分配给它们运行。每一个 P 都维护有本地队列，此外还共享一个全局队列。
    - 本地队列：当前 P 独享，用于存储当前正在执行或等待执行的 G。
    - 全局队列：所有 P 共享，用于存储等待执行的 G。

个人认为 GMP 模型的最大亮点，是在用户态完成了所有任务的调度，相比较于多线程模型，大大减少了内核态线程调度的开销。

#### 创建一个协程
1. 通过 `go` 关键字创建一个协程，它会被放入当前线程的本地队列
2. 当本地队列满了时，会取本地队列前一半的协程任务丢到全局队列中。

#### 执行一个协程
1. M 和 P 相互绑定，从 P 的本地队列获取一个协程任务执行
2. 当本地队列为空时，会从全局队列获取协程任务执行
3. 当全局队列为空时，会从其他 P 偷取（work stealing）一定协程任务执行

#### 协程阻塞
1. 当协程发生IO阻塞时，阻塞中的 M 会主动让出，让 P 可以和空闲 M 绑定执行任务
2. 当阻塞中的 M 完成IO操作后，会尝试和之前的 P 获取关联，如果无法获取，则将任务放到全局队列

#### 抢占机制
- hand off（协作式抢占）：遇到阻塞时主动让出
- 时间片：调度器会在某个 goroutine 运行的时间片用完时，发生强制抢占，一般是10ms



<br/>

---

## 切片（slice）

### 如何申明和初始化一个切片
```go
var tmp []string
tmp = new([]string)
tmp = make([]string, 0, 10)
tmp := []string{} // 简短变量申明
```

### 切片和数组有什么区别
对于数组来说：
- 数组长度是固定的，长度就是它的属性之一，定义后不可更改
- 数组属于值类型，赋值或者作为参数传递后，不会影响原来的数据

对于切片来说
- 切片长度是动态的，容量不足时可以扩容
- 切片属于引用类型，赋值或者作为参数传递后，会影响原来的数据

### 切片扩容机制
Go1.18 之前切片的扩容是以 1024 为临界点，即：

- 当容量小于 1024 时，扩容一倍。
- 当容量大于 1024 时，扩容四分之一。

Go1.18开始引入了更平滑的机制。

---

## 映射（map）

### 如何申明和初始化一个map
```go
var tmp map[string]string
tmp = new(map[string]string)
tmp = make(map[string]string)
tmp := map[string]string{} // 简短变量申明
```

### 如何删除map中的元素
```
delete(myMap, "b")
```

---

### map底层原理
map底层原理基本都是基于哈希表实现的。他底层是一个数组，每一个元素都可以叫做哈希桶。
当操作map的时候，会先对key值进行哈希计算，并基于桶大小，可以通过类似取余算法唯一映射到一个桶中。从而实现快速定位。

在map中有一个特别的点需要注意，就是哈希冲突。当不同的key映射到同一个哈希桶中，就是哈希冲突。
这时可以通过拉出一个链表来解决。当链表长度过长的时候，就需要rehash重新申请更大的哈希表。

---

## 通道

### 有缓存和无缓存通道
无缓冲通道，是同步通信的。有缓冲通道，支持一定容量的异步通信。

### 对已经关闭的chan进行读写会怎么样
对已经关闭的通道（chan）进行读取操作是安全的，它会返回通道元素的零值（对于大多数数据类型是零值）。  
对已经关闭的通道进行写入操作会引发 panic

---

## 字符串

### 单引号，双引号，反引号的区别
在 Go 中，单引号（`'`）、双引号（`"`）和反引号（\`）分别用于表示字符、字符串字面值和原始字符串字面值，它们在用法和含义上有不同的区别：

- 单引号用一个整数值（通常是 `rune` 类型）。例如，'A' 表示字符 'A'，而不是字符串 "A"。
- 双引号表示字符串。会对字符串内容进行转移。
- 反引号表示多行字符串。不会对字符串内容进行转移。

### 如何高效地拼接字符串
strings.Join ≈ strings.Builder > bytes.Buffer > "+" > fmt.Sprintf

- `strings.Builder`：**基于指针与切片**，直接把[]byte转换为string，从而**避免变量拷贝**。
- `strings.Join`：基于`strings.Builder`，且优化了切片空间性能更高。
- `+`：会对字符串进行遍历，计算并**开辟一个新的空间**来存储原来的两个字符串。
- `fmt.Sprintf`：**基于反射实现**，有一定性能损耗。

---

## fmt

### 结构体如何输出日志
- %v：输出结构体各成员的值
- %+v：输出结构体各成员的名称和值
- %#v：输出结构体名称和结构体各成员的名称与值

---

## struct

### 空struct有什么用
占位符

### 类型转化与断言
对于一个 `interface` 类型数据，我们可以通过 `interface.(type)` 进行类型转化。
这种属于强制类型转化，转化不同类型值时是会报错的，所以还支持 `_, ok = interface.(type)` 返回两个参数，
第二个参数是布尔类型，用于判断是否正确转化类型。

对于一个 `struct` 结构，我们可以通过定义一个 `interface` 空值来声明转化类型。一般用于判断结构体是否实现 `interface` 接口。
```go
type Interface interface{}

type Struct struct {}

var _ Interface = (*Struct)(nil)
```


<br/>

---

## 测试和性能优化

### 内存泄露和协程泄露

#### 什么场景会导致内存泄露
Go 是一种自带内存管理（GC）机制的编程语言，这意味着通常我们不需要手动管理内存。

然而，仍然有些情况会导致内存泄露。一般内存泄露场景大概率是资源管理不当，或者算法实现导致的，比如：

- 没有释放资源：例如打开文件、网络连接等资源，但没有及时的关闭。那这些资源会一直占用内存，进而导致内存泄露。
- 大量字符串拼接：在 Go 中字符串是不可变对象。因此每次对字符串进行拼接操作都会创建一个新的字符串。一旦在某个循环中进行大量字符串拼接操作，将创建大量临时字符串，可能会导致内存泄露。一般通过 `string.Builder` 解决。

#### 什么场景会导致协程泄露
Go 协程泄露是指协程启动后，无法被及时正确地关闭或释放，从而导致内存泄露或其他资源泄露问题。

以下是一些可能导致 Go 协程泄露的场景：

- 协程无法正常退出：当一个协程被启动后，如果没有被正确关闭或没有在适当的时候退出，那么该协程会一直存在并占据资源，进而导致资源泄露。
- 协程之间的循环引用：当多个协程之间形成循环引用时，它们之间的关系可能导致无法释放相关资源，从而导致泄露。
- 网络操作超时或阻塞：当一个协程执行一个网络操作时，如果该操作超时或被阻塞，那么该协程可能会一直存在，导致泄露。

---

### 什么是逃逸分析
逃逸分析用于确定一个变量是分配在栈上还是堆上。
这个分析是为了优化内存分配和性能，以确保在不需要的情况下不会分配不必要的堆内存，从而降低垃圾回收的负担。

Go 语言的逃逸分析可以通过在编译时添加 `-gcflags=-m` 标志来启用。
eg：`go build -gcflags '-m -m -l' xxx.go`

一般逃逸的场景有：

- 变量大小不确定
- 变量类型不确定
- 变量分配内存超过用户栈最大值
- 暴露给了外部指针

---

## 工具

### trace
trace 包提供了一种轻量级的跟踪工具，可以用来分析程序的执行流程。使用 `go tool trace trace.out` 来可视化分析程序的执行。
```go
package main

import (
    "os"
    "runtime/trace"
)

func main() {
    f, err := os.Create("trace.out")
    if err != nil {
        panic(err)
    }
    defer f.Close()

    err = trace.Start(f)
    if err != nil {
        panic(err)
    }
    defer trace.Stop()

    // 你的代码逻辑
}
```

### pprof
pprof 包提供了性能分析工具，可以用于查看 CPU 和内存使用情况。
```go title="web服务在线查看"
package main

import (
    "net/http"
    _ "net/http/pprof"
)

func main() {
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()

    // 你的代码逻辑
}
```

```go title="文件记录"
package main

import (
	"os"
	"runtime/pprof"
)

func main() {
	f, err := os.Create("cpu.pprof")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	pprof.StartCPUProfile(f)
	defer pprof.StopCPUProfile()

    // 你的代码逻辑
}
```

### cover
用于代码覆盖率分析
```go
# 运行测试并生成覆盖率文件
go test -coverprofile=coverage.out

# 查看覆盖率报告（在浏览器中打开）
go tool cover -html=coverage.out
```

---

## 坑点收录

### 坑点-中文长度计算
在 Go 中，字符串底层使用的 byte 序列存储，而 byte 仅占据一个字节，一些中文字符则需要占据 2~4 个字节。
故我们直接通过 `len(string)` 函数计算一个字符串长度时，会得到意想不到的结果，因为实际统计的是 `[]byte` 的长度。
因为字符串的长度是以字节数来计算的，而不是字符数。

而rune是int32的别名，长度4个字节。对于包含中文的字符串，统计方法有：

- 转化成 `[]rune` 类型在计算。
- 使用 `utf8.RuneCountInString(string)` 来获取长度。

---

### 坑点-slice
slice 底层是一个数组，在发送扩容前，切片会复用同一个底层数组，所以可能存在多个切片相互修改数据的坑。

---

### 坑点-defer+修改返回值
defer 是 Go 的一大特色，也叫延迟函数。其特（坑）点有：

- 后进先出
- 入参在执行时确定
- 具名参数，可以被延迟函数修改
    - 对于非具名返回，会创建临时变量存储结果
    - 对于具名参数返回，则不会创建临时变量

什么情况下会修改返回值：
- 具名返回
- 指针返回

---

### 坑点-uint 类型溢出
在 Go 中，溢出不会引发运行时错误或异常，而是会导致结果截断或循环。

以 uint8 为例，它的值范围是0-255，当值超过255之后，会发生一些意料之外的事情。
```go
package main

import "fmt"

func main() {
    var u uint8 = 255
    fmt.Println(u)      // 输出 255

    u = u + 1
    fmt.Println(u)      // 输出 0（溢出了）
}
```

---

### 坑点-for range
:::note
for range 地址不会发生变化。在循环遍历时，是以值覆盖的形式实现，其内存地址不会改变。
:::

对于 `for range`，其特（坑）点有：

- 返回副本。即 `for range` 返回的值并不是原始数据，而是副本，对于需要修改数据的场景，直接修改副本是不生效的，而需要直接操作原始数据。
- 可以使用 `_` 占位符。
- 循环变量重复引用。操作指针类型数据时要额外小心。

---

### 坑点-对比interface
interface 底层结构包含值类型和指针。不用类型的值做对比，可能会有意想不到的结果。

```go title="两个nil不相等"
var value interface
value = nil
fmt.Println(value == nil)
```

<br/>

---

## 编程实战

### 1w个任务，请实现一个并发任务处理器

### 设计一段优雅停止服务的代码
在服务收到系统退出信号时，如何让服务优雅的退出。

1. 信号处理：启动一个协程监听系统信号
2. 上下文：初始化一个root context & cancel，当收到退出指令时执行 cancel


### select chan 如何实现优先级

### 如何将环境变量映射到结构体
