---
title: Redis 题库
sidebar_label: Redis 题库
slug: redis
description: Redis Question Bank😂
---

Redis（Remote Dictionary Server）是一种开源的内存数据存储系统，它可以用作数据库、缓存和消息中间件。

## 基础概念

### 为什么说redis是单线程服务
Redis不是严格意义上的单线程服务。这里的单线程，主要是指redis的核心执行（网络I/O、键值对读写）是单线程完成的。

类似持久化、数据同步等、还是由其他线程执行。

### Redis6.0为什么要引入多线程
Redis6.0在网络IO模块支持多线程，核心键值对读写仍然是单线程。

### Redis单线程为什么性能这么好
1. 基于**内存的数据库**，相比于传统的数据库，在性能上具有天然的优势。
2. 核心执行引擎是单线程，在高并发场景下避免了锁竞争。
3. 通过**事件驱动模型**和**IO多路复用**，实现客户端请求、网络IO的高效处理。
4. 高效的数据结构和算法，如：哈希表、跳表等。

### 事件驱动模型
事件驱动模型是一种**异步编程模型**。这种模型基于事件循环来执行，也就是通过监听和响应事件来处理输入和输出。

在Redis的主线程中，运行着一个事件循环。该`EventLoop`不断地监听和处理发生的事件，如新的客户端连接、数据可读或可写等。

#### 优点
相比于多线程、多进程模型来说，事件驱动模型避免了为每一个请求创建一个线程甚至进程，因此事件驱动模型可以轻松处理大量并大请求。
且不会存在系统调度开销。

#### 缺点
1. 事件驱动模型更适合I/O密集型任务，对于计算密集型任务，不如多线程、多进程模型。
2. 一旦发生阻塞，会影响整个事件循环

### IO多路复用
I/O多路复用是一种操作系统提供的机制，允许单个进程或线程同时监听多个I/O通道的状态，以确定哪个通道有数据可读或可写。这使得程序能够有效地处理多个I/O操作，而不需要为每个I/O通道创建一个独立的线程。主要的I/O多路复用机制包括`select`、`poll`和`epoll`。

### `select`：

`select`是一种传统的I/O多路复用机制，最早出现在Unix系统中。它的工作方式是通过一个文件描述符集合，检查每个文件描述符的状态（可读、可写等）。主要的特点包括：

- **阻塞调用：** 当没有任何文件描述符就绪时，`select`调用会阻塞，等待至少有一个文件描述符就绪。

- **文件描述符数量限制：** 通常有一个限制，例如1024个文件描述符。

- **轮询开销：** `select`采用轮询的方式检查文件描述符的状态，可能会带来一些开销。

### `poll`：

`poll`是对`select`的改进，同样用于多路复用I/O。它的一些特点包括：

- **无文件描述符数量限制：** `poll`没有`select`的文件描述符数量限制。

- **阻塞调用：** 与`select`类似，当没有文件描述符就绪时，`poll`调用也会阻塞。

- **逐个扫描：** `poll`通过逐个扫描文件描述符，找出就绪的文件描述符。

### `epoll`：

`epoll`是在Linux系统上引入的新一代I/O多路复用机制，相对于`select`和`poll`有更高的性能。它的一些特点包括：

- **无文件描述符数量限制：** `epoll`也没有文件描述符数量的限制，可以处理数以万计的并发连接。

- **事件驱动：** `epoll`是事件驱动的，只在有事件发生时进行处理，而不是通过轮询来检查。

- **支持Edge Triggered（ET）模式：** 在ET模式下，只有在状态变化时才会触发事件，而不是像Level Triggered（LT）模式那样持续通知。

- **更高的性能：** 由于采用了事件驱动和其他一些优化，`epoll`在处理大量并发连接时表现更好。

### Redis数据类型

1. **字符串（String）：**
    - **简介：** 字符串是Redis最简单的数据类型，可以包含任意类型的数据，包括文本和二进制数据。
    - **用途：** 通常用于存储简单的键值对数据，也可用于缓存和计数器等场景。
    - **数据结构**：简单动态字符串类型
      - 整数：采用int编码，元数据8字节+int8字节，共计16字节
      - 长度小于44：采用紧凑型编码。
      - 长度大于44：采用指针。
    - **命令示例：**
      ```redis
      SET mykey "Hello"
      GET mykey
      ```

2. **哈希（Hash）：**
    - **简介：** 哈希是一个键值对集合，每个哈希可以存储多个字段和对应的值，类似于关联数组。
    - **用途：** 适合存储对象，如用户信息、配置项等，便于按字段进行读写操作。
    - **数据结构**：
      - 哈希表
      - 压缩列表
    - **命令示例：**
      ```redis
      HSET user:1000 username "john_doe"
      HGET user:1000 username
      ```

3. **列表（List）：**
    - **简介：** 列表是一个有序的字符串元素集合，支持在两端执行插入和删除操作。
    - **用途：** 适用于队列、栈等数据结构，可按顺序存储多个元素。
    - **数据结构**：
      - 双向链表
      - 压缩列表
    - **命令示例：**
      ```redis
      LPUSH mylist "item1"
      RPUSH mylist "item2"
      LRANGE mylist 0 -1
      ```

4. **集合（Set）：**
    - **简介：** 集合是一个无序的字符串元素集合，元素是唯一的。
    - **用途：** 适用于存储唯一值，如用户标签、好友关系等。
    - **数据结构**：
      - 哈希表
      - 整数数组
    - **命令示例：**
      ```redis
      SADD myset "value1"
      SADD myset "value2"
      SMEMBERS myset
      ```

5. **有序集合（Sorted Set）：**
    - **简介：** 有序集合是集合的扩展，每个元素都有一个分数，可以按升序或降序排列。
    - **用途：** 适用于需要排序的场景，如排行榜。
    - **数据结构**：
      - 跳表
      - 压缩列表
    - **命令示例：**
      ```redis
      ZADD myzset 1 "value1"
      ZADD myzset 2 "value2"
      ZRANGE myzset 0 -1 WITHSCORES
      ```

6. **位图（Bitmap）：**
    - **简介：** 位图是一种特殊的字符串，可进行位操作，常用于存储和处理状态信息。
    - **用途：** 例如用户在线状态、签到记录等。
    - **命令示例：**
      ```redis
      SETBIT mybitmap 0 1
      GETBIT mybitmap 0
      ```

7. **HyperLogLog：**
    - **简介：** HyperLogLog是一种基数估算算法，用于估计集合中不同元素的数量，具有固定的空间复杂度。
    - **用途：** 适用于估算大规模数据集合的基数，如网站访问用户数。
    - **命令示例：**
      ```redis
      PFADD myhyperloglog element1 element2 element3
      PFCOUNT myhyperloglog
      ```

8. **Geo（地理空间）：**
    - **简介：** Geo是用于处理地理空间信息的数据类型，主要用于存储地理位置坐标。
    - **用途：** 适用于实现位置相关的应用，如附近的商家、地点推荐等。
    - **命令示例：**
      ```redis
      GEOADD mylocations 13.361389 38.115556 "Palermo" 15.087269 37.502669 "Catania"
      ```

### 什么场景下可能造成Redis阻塞，如何避免
Redis 可能在多种场景下发生阻塞，主要的原因包括：

1. **持久化操作：** 当 Redis 执行持久化操作（如RDB快照或AOF文件重写）时，它可能会阻塞对数据库的正常读写操作。持久化操作可能会导致一些短暂的阻塞，具体取决于数据的大小和系统的性能。

   - **避免方法：** 可以通过合理配置持久化策略，选择合适的持久化方式（RDB或AOF）以及调整触发持久化的时机来减轻持久化操作对性能的影响。另外，可以考虑使用 Redis 的持久化异步化特性，如AOF的`fsync`选项，以减少阻塞时间。

2. **主从同步：** 当 Redis 配置了主从复制时，主节点与从节点之间的数据同步也可能导致阻塞。主节点在进行全量同步或部分重同步时，从节点可能会暂时阻塞。

   - **避免方法：** 可以通过合理设置复制选项，例如选择合适的复制缓冲区大小，避免在高峰期进行同步等来减轻主从同步对性能的影响。

3. **慢查询：** 当 Redis 执行慢查询时，可能会阻塞其他请求的执行。
   - 全量键值对查询
   - 复杂的聚合计算
   - BigKey写入于删除
   - 清空数据库
   - **避免方法：** 定期检查慢查询日志，通过优化查询语句、使用索引等手段提高查询性能。此外，可以设置合适的超时时间，对于长时间运行的查询进行适当的限制。

4. **内存压力：** 当 Redis 的内存使用达到系统可用内存的上限时，系统可能会开始进行内存回收，这可能导致 Redis 在一段时间内被阻塞。

   - **避免方法：** 监控 Redis 的内存使用情况，合理设置内存策略，考虑在需要时使用分片或集群来扩展内存容量。

### 请介绍下Redis哈希表底层原理
哈希表底层是基于数组实现的。数组中每一个元素我们称之为哈希桶。当发生键值对操作时，首先对key值进行哈希运算，
并将哈希唯一映射到某一个哈希桶中。因此，哈希表可以实现一个近似O(1)的操作。

### Redis与Memcached之间有什么区别？在什么情况下选择Redis或Memcached？
- Redis拥有更丰富的我数据结构，支持持久化、淘汰、事务、集群等功能
- Memcached仅支持键值对缓存

### 如何使用Redis实现分布式锁
可以使用SET命令来获取锁，结合NX（如果不存在）和EX（设置过期时间）参数，确保锁的独占性和自动释放。

```shell title="获取锁"
SET lock_key my_unique_identifier NX EX 30
```

可以使用Lua脚本来释放锁
```shell title="释放锁-Lua脚本"
if redis.call("GET", KEYS[1]) == ARGV[1] then
   return redis.call("DEL", KEYS[1])
else
   return 0
end
```

### 内存淘汰策略
1. **No Eviction (无淘汰策略):**
   - 如果配置为无淘汰策略，当内存超过限制时，Redis会拒绝写入操作，直到足够的内存被释放为止。这样可以确保不会删除任何数据，但也可能导致服务不可用。
2. **All Keys Random (随机淘汰):**
   - 这种策略会从所有的键中随机选择一些进行淘汰。虽然简单，但可能导致一些热门的数据被删除，从而影响性能。
3. **Volatitle TTL (根据TTL淘汰):**
   - 在这种策略中，Redis会优先淘汰具有较短TTL（生存时间）的键。这样做可以确保首先删除那些很快就会过期的数据，腾出空间来存储新的数据。
4. **Least Recently Used (LRU - 最近最少使用):**
   - LRU算法会根据最近访问的时间来淘汰最少使用的键。当内存不足时，选择最近最少使用的键进行淘汰。这通常是一个比较有效的策略，因为一般而言，很少被访问的键可能很久没有使用过，有可能不再需要。
5. **Least Frequently Used (LFU - 最不经常使用):**
   - LFU算法会根据键被访问的频率来淘汰最不经常使用的键。具有较低访问频率的键会被优先淘汰。


### 除了缓存还有那些应用场景
- 缓存
- 分布式锁
- 消息队列
- 布隆过滤器
- 排行榜
- 秒杀场景

### Redis的持久化机制有哪些，它们之间的区别是什么？
Redis有两种持久化方式：RDB快照和AOF日志
- RDB是周期性生成快照
- AOF记录每个写操作

### Redis 持久化机制

Redis 使用两种主要的持久化机制，分别是 Append-Only File (AOF) 和 Redis DataBase (RDB)。

#### 1. AOF（Append-Only File）
- **工作原理：** AOF 以日志形式记录所有写操作。当Redis重新启动时，会重新执行AOF文件中的写操作，从而还原数据。
- **写回策略：**
  - **Always**：同步写回
  - **Everysec**：每秒一次，将缓冲区数据刷新到磁盘
  - **No**：由操作系统控制写回。
- **优点：**
   - 持久化过程中，数据基本上是实时写入的，因此对数据的损失较小。
   - AOF 文件是一个可读的文本文件，方便查看和调试。
- **缺点：**
   - AOF 文件相对较大，因为它包含了所有写操作的历史记录。
   - AOF 持久化对系统的写入性能有一定的影响。
- **FAQ：**
  - **AOF 文件过大如何处理**：通过 `BGREWRITEAOF` 指令来重写AOF日志。其原理就是将同一个key的操作合并。
  - **AOF 重写是否会阻塞 redis**：重写由后台线程完成，不会阻塞主线程
  - **AOF 重写期间新的写操作如何保存**：新的写操作会先暂存到重写缓冲区，等重写完成后再追加。

#### 2. RDB（Redis DataBase）
- **工作原理：** RDB 是一种快照机制，记录某一时刻的全量数据。
- **优点：**
   - RDB 文件相对较小，适用于数据备份。
   - 恢复速度比 AOF 快，因为只需加载一个文件即可。
- **缺点：**
   - 由于是定期快照，因此在两次快照之间可能会有数据丢失。
   - 在数据量较大时，生成 RDB 文件可能会影响 Redis 的性能。

### 区别

- **数据恢复：** AOF 以日志形式追加写入，更加实时，但在故障恢复时可能比 RDB 更慢。RDB 是定期快照，速度较快，但可能会有数据丢失。

- **文件体积：** AOF 文件相对较大，包含所有写操作历史。RDB 文件较小，仅包含快照数据。

### 优缺点

#### AOF：

- **优点：**
   - 数据实时写入，故障时数据较完整。
   - 可以通过配置不同的同步策略来平衡性能和数据完整性。

- **缺点：**
   - AOF 文件相对较大。
   - 对写入性能有一定影响。

#### RDB：

- **优点：**
   - RDB 文件较小，适合备份和传输。
   - 恢复速度较快。

- **缺点：**
   - 定期快照可能导致数据丢失。
   - 在生成快照时可能影响性能。

### 适用场景

- **AOF 适用于：**
   - 需要较实时数据恢复的场景。
   - 对一些数据损失可以容忍的场景。

- **RDB 适用于：**
   - 对数据一定程度的丢失可以接受的场景。
   - 需要较小备份文件的场景。

### 优化点

#### AOF：

- 调整同步策略：通过修改`appendfsync`配置来平衡写入性能和数据完整性。

#### RDB：

- 调整保存频率：通过修改`save`配置来调整快照的保存频率。
- 合理使用压缩：通过压缩快照文件来减小文件大小。

### 运维可能遇到的问题

- **AOF 文件过大：** 定期检查 AOF 文件大小，如果过大，可以选择手动重写 AOF 文件或者使用 `BGREWRITEAOF` 命令触发重写。

- **RDB 文件生成时性能问题：** 如果生成 RDB 文件对性能影响较大，可以考虑调整保存频率，或者使用主从复制的方式生成 RDB 文件。

- **AOF 与 RDB 同时使用：** 有时候可以同时使用 AOF 和 RDB，AOF 用于实时恢复，RDB 用于定期备份。

- **数据丢失问题：** 根据业务需求选择合适的持久化方式，可以权衡性能和数据完整性。


<br/>

---

## 缓存

### 什么是缓存击穿、缓存穿透、缓存雪崩、缓存预热
- 缓存击穿是指热点Key过期
- 缓存穿透是指一个不存在于缓存中的键频繁被请求
- 缓存雪崩是指大量缓存同时失效
- 缓存预热是在系统启动时将热门数据加载到缓存中，以提高系统的性能和稳定性

### Redis缓存淘汰策略

### Redis持久化机制有那些

<br/>

---

## 持久化

### RDB

### AOF


<br/>

---


## 集群

### 什么是Redis集群
Redis集群是多个Redis节点的分布式集群，可提供高可用性和横向扩展。
配置和管理Redis集群需要使用redis-trib脚本或Cluster模式。

### 主从复制


### 切片集群

### 为什么会发生数据倾斜，如何避免

### 哨兵机制


<br/>

---

## 进阶

### Redis的哨兵（Sentinel）是用来做什么的？它如何确保高可用性？
Redis Sentinel是用于监控和管理Redis主从复制集群的工具，可以自动故障转移主服务器。

### 什么是Redis Pipeline，和事务有什么区别？
Redis Pipeline允许一次性发送多个命令，减少了通信开销，提高了性能，特别是在批量操作时。
其中，Redis Pipeline不是原子操作，执行失败不会回滚。而事务是原子操作，执行失败会回滚。

### 什么是Redis事务？如何保证事务的一致性？
Redis事务是一组命令，可以按顺序执行。
通过MULTI和EXEC命令，可以保证事务的原子性，要么全部执行成功，要么全部失败。

### 请介绍下Redis Watch机制
Redis的乐观锁机制是通过WATCH命令来实现的，用于在事务中实现并发控制。

WATCH命令用于监视一个或多个键，一旦对这些键的值发生更改，与这些键相关的事务将被取消。
通常WATCH配合事务（MUTIL/EXEC）执行。

### Redis事务和Lua脚本有什么区别？
Redis事务和Lua脚本都涉及原子性操作，要么全部成功，要么全部失败。除此之外：
- Redis事务是一组Redis命令的集合，按顺序执行
- Lua脚本是在Redis中执行的Lua编程语言脚本，支持条件控制、循环、业务逻辑等复杂命令的组合

<br/>

---

## 运维

### 如何清空Redis并将影响降到最低

### 如何监控和调试Redis性能问题？
使用Redis内置命令如INFO和MONITOR来监控性能，同时可以使用第三方工具如Redis的慢查询日志和监控工具。
