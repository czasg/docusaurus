---
title: MySQL 题库
sidebar_label: MySQL 题库
slug: mysql
description: 收录MySQL常见面试题库
---

## 1.MySQL基础

### 数据库设计三大范式
数据库设计的三大范式是一组设计原则。

- 第一范式（1NF）：要求原子性
  - 举例：除了主键之外，其他字段数据一样，这种就不满足第一范式
- 第二范式（2NF）：要求非主键字段与主键之间不允许部分依赖
  - 举例：主要针对联合主键场景，非主键字段仅依赖联合主键其中一个字段，这种就不满足第二范式
- 第三范式（3NF）：要求非主键字段与主键之间不允许传递依赖
  - 举例：假设存在书籍和发版社两张表。因为书籍和发版社是存在关联的，现在把他们放在一张表里，那么就会存在传递依赖的关系。

```sql title="不满足范式一，1和3不符合原子性"
| BookID | Title                  | Author                | PublicationDate | Publisher           |
|--------|------------------------|-----------------------|-----------------|---------------------|
| 1      | "The Great Gatsby"     | "F. Scott Fitzgerald" | 1925            | "Scribner"          |
| 2      | "Pride and Prejudice"  | "Jane Austen"         | 1813            | "Penguin Classics"  |
| 3      | "The Great Gatsby"     | "F. Scott Fitzgerald" | 1925            | "Scribner"          |
```

```sql title="不满足范式二，一般存在于联合主键场景，导致部分依赖"
| StudentID | CourseID | CourseName         | Teacher          |
|----------|----------|--------------------|-------------------|
| 1        | 101      | "Mathematics 101"  | "Mr. Smith"       |
| 1        | 102      | "Physics 101"      | "Ms. Johnson"     |
| 2        | 101      | "Mathematics 101"  | "Mr. Smith"       |
| 2        | 103      | "Chemistry 101"    | "Dr. Brown"       |
```

```sql title="不满足范式三，存在传递依赖，应该拆表"
| BookID | Title                  | Author                | PublicationDate | Publisher           |
|--------|------------------------|-----------------------|-----------------|---------------------|
| 1      | "The Great Gatsby"     | "F. Scott Fitzgerald" | 1925            | "Scribner"          |
| 2      | "Pride and Prejudice"  | "Jane Austen"         | 1813            | "Penguin Classics"  |
| 3      | "The Great Gatsby"     | "F. Scott Fitzgerald" | 1925            | "Scribner"          |
```

### DML、DDL
DML是数据库操作语言。常指对数据的管理操作，常见有增删改查操作，比如：SELECT、INSERT、UPDATE、DELETE  
DDL是数据库定义语言。常指数据库结构的操作。比如：ALERT、TRUNCATE

### 服务层组成
- 连接器：负责建立用户连接，初始化权限，管理连接
- 查询缓存
- 分析器：词法解析
- 优化器：基于索引所化查询
- 执行器：调用引擎层接口操作数据

### 一条SQL的执行过程

#### 查询语句执行过程：

- 建立连接：MySQL 连接器负责建立用户连接，包括初始化用户权限等基础信息。
- 查询缓存：对于已经存在缓存的查询语句，MySQL 会直接返回缓存结果。
- 语法分析：MySQL 会对 SQL 进行解析并检查是否存在语法错误。
- 查询优化：一条 SQL 的执行策略是多样的，比如可以走全表扫描，或者走某个索引等。
  此处的查询优化就是根据表的大小、索引等信息，再结合 SQL 的查询条件，综合选择最优查询方案。
- 执行语句：MySQL 的数据操作是基于存储引擎实现的。此处的执行是调用存储引擎接口实现。

#### 更新语句执行过程：


<br/>

---

## 2.MySQL存储引擎

### 介绍下常见的存储引擎

MySQL 是一个开源关系型数据库管理系统，支持多种不同的存储引擎。

存储引擎是 MySQL 用于管理数据的基础组件，它们负责处理 SQL 语句，包括读取和写入数据等操作。
常见的存储引擎有：

- InnoDB：InnoDB 是 MySQL 默认的存储引擎，它支持事务、外键和行级锁等特性。
- MyISAM：MyISAM 是 MySQL 最古老的存储引擎之一，不支持事务和行级锁，这也是它被 InnoDB 取代的很大一部分原因之一。
  但它非常适合用于处理大量的读取操作，例如数据仓库和日志文件等。
- Memory：Memory 存储引擎将内存存储引擎，优点是速度非常快，缺点就是数据是非持久的。

---

### 介绍下InnoDB与MyISAM区别

InnoDB和MyISAM是两个常用的存储引擎，用于MySQL数据库管理系统，它们在功能、性能和适用场景上有一些重要的区别。以下是它们之间的主要区别：

1. **事务支持：**InnoDB支持事务（ACID属性），MyISAM不支持事务

2. **锁机制：**InnoDB使用行级锁（row-level locking），MyISAM使用表级锁（table-level locking）

3. **外键支持：**
    - InnoDB支持外键完整性约束，可以定义外键关系，确保数据的完整性。
    - MyISAM不支持外键，不能定义外键关系。

4. **崩溃恢复：**
    - InnoDB支持崩溃恢复，具有事务日志和事务回滚功能，可以更好地处理数据库崩溃时的数据完整性。
    - MyISAM不具备崩溃恢复功能，容易在崩溃时丢失数据。

6. **空间和性能：**
    - InnoDB通常需要更多的磁盘空间来存储数据，因为它维护额外的事务日志和索引结构。
    - MyISAM在一些情况下可能在性能上表现更好，特别是在只读操作较多的情况下。

<br/>

---

## 3.MySQL事务

### 什么是事务

事务是一组数据库操作的逻辑单元。这些操作要么全部成功，要么全部失败。因此它具有ACID属性：

1. **原子性（Atomicity）**：事务是原子的，意味着它要么完全执行，要么不执行。如果事务的任何部分失败，整个事务将被回滚，数据库将恢复到事务开始之前的状态，以确保数据的一致性。

2. **一致性（Consistency）**：事务的执行将数据库从一个一致状态转移到另一个一致状态。这意味着事务的执行不会破坏数据库的完整性约束或数据关系。

3. **隔离性（Isolation）**：每个事务应该在不受其他事务干扰的情况下执行，即使多个事务同时运行也不会相互干扰。这意味着事务之间应该是相互隔离的，以防止数据冲突。

4. **持久性（Durability）**：一旦事务成功提交，其结果应该是永久性的，并且在系统故障或重启后仍然保持。这要求数据库将事务的变更持久地保存在存储设备上，以确保数据的持久性。

### 事务隔离级别

MySQL 是一个关系型数据库管理系统，它支持多个事务之间的并发执行。因此需要保障事务之间的隔离性和数据一致性。

MySQL 提供了四个事务隔离级别，它们分别是：

- READ UNCOMMITTED（读未提交）：最低级别的隔离级别。事务可以读取另一个事务尚未提交的数据。在此隔离级别下，**会存在脏读、不可重复读和幻读**等问题。
- READ COMMITTED（读已提交）：默认的隔离级别。事务只能读取另一个已提交的事务的数据。在此隔离级别下，解决了脏读的问题，**但仍然存在不可重复读、幻读**的问题。
- REPEATABLE READ（可重复读）：事务开始时读取的数据集合将保持不变，即使其他事务对这些数据进行了修改或插入操作，也不会影响该事务。这种隔离级别解决了不可重复读的问题，**但是仍然存在幻读**问题。
- SERIALIZABLE（序列化）：最高级别的隔离级别，多个事务之间顺序执行。在此隔离级别下，事务之间不会存在冲突，但会牺牲性能。

### 什么是脏读

当一个事务可以读取另一个事务尚未提交的数据，而另一个事务随后被回滚，那么当前事务读取到的数据就是无效的。

这类现象被称之为**脏读（Dirty read）**，因为它读到了脏数据。

### 什么是不可重复读

**不可重复读**是指，当一个事务，在某个时间段内，多次读取同一行数据，出现的数据不一致的场景。

不可重复读是数据库隔离级别中的一种问题，常在读未提交、读已提交隔离级别中发生。

不可重复读与幻读的区别在于，不可重复读关注的是同一行数据在一个事务内的两次读取之间是否一致，
而幻读关注的是两次查询的结果集的行数是否一致。

### 什么是幻读

**幻读**是指，当一个事务中，在某个时间段内，多次执行同一个范围查询结果集时，出现的数据不一致的场景。

幻读是数据库隔离级别中的一种问题，常发生于范围查询场景。在可重复读隔离级别下是比较常见的。

#### 如何避免幻读

1. 使用更严格的序列化事务隔离级别。但会带来较大的性能损耗。
2. 使用行锁和间隙锁。通过在SQL语句中使用 `FOR UPDATE` 实现。
   - `FOR UPDATE NOWAIT`：如果无法获得锁，立即返回而不是等待
   - `FOR UPDATE SKIP LOCKED`：如果无法获得锁，跳过而不是等待
3. 在应用层实现乐观锁，每次执行语句时去检查一遍。



---

### MVCC
多版本并发控制（MVCC）是一种数据库事务并发控制的机制，其实现原理主要涉及**版本号的管理**，
以及对数据的**读取和写入时的一致性处理**（基于ReadView决定事务可以看到那些数据版本）。

以下是MySQL的MVCC实现原理的主要步骤：

1. **版本号分配：** 每个事务都被分配一个唯一的事务标识（Transaction ID）。对于每个被修改的数据行，都会为其分配一个版本号，通常是事务的ID。这个版本号会标记数据行的状态，指示数据行的修改历史。

2. **Read View：** 在启动事务时，会生成一个Read View，包含当前事务的事务ID。Read View决定了事务能够看到哪些数据版本。Read View的生成可能包括一些额外的信息，例如事务启动时的系统版本号。

3. **Read操作：** 当一个事务执行读操作时，系统会使用Read View来判断当前事务能够看到哪些数据版本。只有那些版本号早于或等于Read View的数据版本才能被当前事务读取。这确保了事务读取的数据是一致的，不受其他并发事务修改的影响。

4. **Write操作：** 当一个事务执行写操作时，会在数据行上创建一个新的版本。新版本的版本号是事务的ID。原始数据行的版本号被更新为新版本的版本号。这样，新版本的数据行对于新的读操作是可见的，而对于旧的Read View是不可见的。

5. **回滚和垃圾回收：** 当一个事务被回滚时，相关的修改可以被丢弃，不会影响其他事务。定期执行垃圾回收操作来删除不再需要的旧版本数据，以释放存储空间。


<br/>

---

## MySQL索引

### 什么是索引
索引是一种用于提高数据库查询效率的数据结构。类似于书籍的目录一样，索引可以让你不用扫描全表，而是通过索引字段，快速定位到特定的数据行。

### 索引的优缺点
**优点**
- 提高数据检索效率
- 提高排序效率

**缺点**
- 占用存储空间
- 降低插入、更新、删除的速度

### 那些场景试合使用索引
以下场景试合使用索引：

- 查询频率高
- 唯一性好
- 更新频率低

相反，如果查询频率低，唯一性不好、更新频率高，那么就不适用使用索引。

### 索引的类型

MySQL支持多种类型的索引，以提高查询性能和加速数据检索。以下是一些常见的MySQL索引类型：

1. **B-树索引（B-Tree Index）：** B-树索引是最常见的索引类型，在大多数情况下都可以满足需求。它适用于**精确匹配、范围查询、排序操作等**。
2. **哈希索引（Hash Index）：** 哈希索引将索引键的值经过哈希函数计算后存储在索引中，用于加速等值查询。它对于**等值查询**非常高效，但**不支持范围查询或排序操作**。
3. **复合索引（Composite Index）：** 复合索引是包含多个列的索引。它可以用于**加速多列查询、减少索引数量**，但要遵循最左前缀原则。
3. **前缀索引（Prefix Index）：** 前缀索引是对列值的前缀进行索引，而不是整个值。它可以**用于节省索引存储空间和加速检索**。前缀索引适用于较长的字符串列。
4. **外键索引（Foreign Key Index）：** 外键索引用于连接不同表格之间的关系。它通常与外键约束一起使用，以**确保数据完整性**。
5. **唯一索引（Unique Index）：** 唯一索引要求索引列的值在表中是唯一的，用于**强制数据的唯一性**。它适用于任何数据类型。
6. **主键索引（Primary Key Index）：** 主键索引是唯一索引的一种，**通常用于标识表中的每一行**。它确保每行都**具有唯一**的主键值。
8. **全文索引（Full-Text Index）：** 全文索引用于对文本数据进行全文搜索。它允许模糊匹配、词干搜索和布尔搜索。全文索引适用于TEXT和VARCHAR列。


### 二叉树、B-Tree和B+Tree区别
二叉树是每个节点最多有两个子节点的树结构。

其中，二叉查找树，是在树结构的基础上。定义了左子树节点小于父树节点小于右子树节点。

B-Tree和B+Tree都可以看作一种特殊的多叉查找树。其中B-Tree也叫平衡树、而B+Tree则是B-Tree的一种变种。

B-Tree和B+Tree在节点**存储方式**和**连接方式**上有一定的区别：

**存储方式：**
- B-Tree：非叶子节点和叶子节点既存储键值，也存储实际的数据
- B+Tree：非叶子节点存储键值，叶子节点上存储实际数据

**连接方式：**
- B-Tree：各节点通过指针进行连接
- B+Tree：各节点通过指针进行连接，此外，叶子节点是一个有序链表。因此，B+Tree在范围查询和排序方面有更强的优势

B-Tree更适合随机访问的场景，B+Tree更适合范围查询、顺序遍历、排序等场景。

### 聚簇索引和非聚簇索引
聚簇索引，其叶子节点存储的是真实数据行。非聚簇索引，其叶子节点存储的是指向真实数据行的地址。

它们是更大的概念，在MySQL中，主键索引通常是聚簇索引，普通的索引通常是非聚簇索引。

### 为什么推荐使用自增主键作为索引
使用自增主键作为索引是一种常见的索引所化。它使得存储更加有序，这可以减少索引碎片，提高空间利用率，从而提高查询效率。
此外，有序的数据也会提高插入效率。

### 为什么 MySQL 的自增主键不连续
正常情况下自增主键是严格递增的。但是在一些场景下可能表现出不连续：
- 事务回滚
- 数据删除

以上场景下，自增主键计数器并不会减少

### 如何理解块索引

通常来说，块索引（Block Index）不是一个独立的索引类型，而是一个较低级别的概念，
用于描述数据库引擎内部索引结构的存储方式。

但在PostgreSQL中，块索引是一个高级特性。
它通常用于特定类型的应用场景，特别是那些需要处理大量块级别数据的场景，例如时间序列数据库或列式数据库。
它支持以下特性：

1. **范围查询（Range Queries）**：块索引可用于支持范围查询，例如查找某个范围内的数据块。这对于处理时间序列数据等应用非常有用。

2. **块级别的检索**：块索引直接在数据块级别存储索引信息，从而可以加速块级别的检索，而不是单个行级别的检索。

3. **块合并和块分割**：块索引对于块合并（Block Merging）和块分割（Block Splitting）等操作非常高效，这些操作通常用于数据块的管理。

### 索引覆盖、索引下推
- **索引覆盖**：就是查询的值已经存在于索引中了，那么就可以直接返回，不需要再回表查询一次。
- **索引下推**：就是过滤的字段存在于索引中，那么就可以通过索引字段直接过滤，从而减少回表次数。

### 主键和外键的区别

主键可以作为每一行数据的唯一性标识。
外键则是用于维护数据完整性和建立表格之间关系的一种强约束。

### 最左前缀原则

### 无法命中索引的情况
1. 查询条件没有使用索引字段
2. 使用了函数，破坏了索引的有序性
3. 发生了隐式类型转化、隐式编码转化，类似于套上了一个转化函数
4. 查询优化器判定不使用索引
   - 对非索引字段使用了 `ORDER BY` 导致优化器判定走全表扫描
   - 数据表高频增删改，数据库统计信息更新不及时，导致优化器判定异常

对于这种索引失效的场景，可以多使用 `EXPLAIN` 分析下。

### 读写分离和分库分表

### char和varchar区别

- CHAR 是一种固定长度的字符数据类型
- VARCHAR 是一种可变长度的字符数据类型

<br/>

---

## 日志

### 什么是 WAL
WAL 是 Write-Ahead Logging 的简写。是一种预写日志技术。它主要有两个作用：
- crash safe（崩溃恢复）：它记录在数据库引擎层面发生的事务修改，当数据库发生故障时，可以通过重新 redo log 来将数据库恢复到一致的状态。
- 将随机写转化为顺序写：

### redo log
Redo Log 是一种崩溃恢复的机制，它记录在数据库引擎层面发生的事务修改，当数据库发生故障时，可以通过重新 redo log 来将数据库恢复到一致的状态。

```text title="redo log 记录数据页的物理修改"
Transaction ID: 123
LSN: 456
Page ID: employees_page_102
Modification Type: UPDATE
Modified Data: 
  - Employee ID: 102
  - New Salary: 20000
```

此外，redo log 将随机写转化为顺序写，具体过程如下：

1. 用户或应用程序发起一个事务。
2. 在事务执行过程中，相关的数据修改操作首先被写入数据库表中，修改了内存中的数据。
3. 同时，相应的 Redo Log 记录会被生成并写入 Redo Log 文件。这些记录包含了已经对数据表进行的物理修改。
4. 当事务顺利完成，用户或应用程序执行提交操作。

### redo log数据结构

### redo log刷盘机制

### binlog
binlog 全称 Binary Log（二进制日志），是 MySQL 用于记录数据库更改的一种日志文件。
它包含了对数据库进行修改的所有信息，例如插入、更新、删除等操作。常用于**主从复制**和**数据恢复**。

1. **记录格式：**
   - **Statement**：记录原生的SQL语句
   - **Row**：记录具体修改的数据
   - **Mixed**：基于Statement和Row，对于可能造成数据不一致的场景选择Row，否则选择Statement

2. **作用：**
    - **主从复制：** Binlog是MySQL主从复制的核心。主数据库记录所有的变更，而从数据库通过读取binlog实现与主数据库的同步。
    - **数据恢复：** Binlog可以用于恢复数据库到之前的状态，从而避免数据丢失。
    - **数据库备份：** Binlog可以与数据库快照结合，用于创建一致性的备份。

### binlog日志格式
binlog 主要有三种：

1. **Statement-Based Replication (SBR):**
    - **工作原理：** 这种格式记录的是SQL语句，即在主服务器上执行的SQL语句。当在主服务器上执行一个SQL语句时，这个语句会被记录到binlog中，而从服务器会读取这个binlog，并在从服务器上执行相同的SQL语句。
    - **优点：** 相对较小的日志文件大小，因为只需记录SQL语句。
    - **缺点：** 由于是基于语句的，可能会出现在主从服务器上执行相同SQL语句时导致的不一致性问题。例如，由于数据不同步或随机因素导致的不同结果。

2. **Row-Based Replication (RBR):**
    - **工作原理：** 这种格式记录的是对表中行的实际更改。当在主服务器上进行数据更改时，binlog会记录哪些行受到了影响，以及发生了什么变化。而从服务器会根据这些变化来修改对应的数据行。
    - **优点：** 更加精确，可以确保主从服务器的数据一致性。
    - **缺点：** 相对较大的日志文件大小，因为需要记录更详细的信息。

3. **Mixed Format:**
    - **工作原理：** 这是SBR和RBR的混合格式。MySQL会根据执行的具体操作选择使用SBR还是RBR。
    - **优点：** 兼顾了SBR和RBR的优点，既可以减小日志文件大小，又可以保持数据的一致性。
    - **缺点：** 需要更多的判断和逻辑来确定使用哪种格式，可能会增加一些复杂性。

```sql title="statement 和 row 对比"
-- SQL语句
UPDATE employees SET salary = salary * 1.1 WHERE department_id = 2;

-- 对应的binlog记录（SBR）
### UPDATE `employees` SET `salary` = `salary` * 1.1 WHERE `department_id` = 2;

-- 对应的binlog记录（RBR）
### UPDATE `employees` SET `salary` = 22000 WHERE `employee_id` = 101;
### UPDATE `employees` SET `salary` = 19800 WHERE `employee_id` = 102;
### UPDATE `employees` SET `salary` = 24200 WHERE `employee_id` = 103;
```

### redolog和binlog的区别是什么
在生效机制上：redolog 是 Innodb 独有的日志，而 binlog 是 server 层的，所有的存储引擎都有使用到；

存储结构上：binlog 大小达到上限或者 flush log 会生成一个新的文件，而 redolog 有固定大小只能循环利用；

数据内容上：redolog 记录了具体的数值，对某个页做了什么修改，binlog 记录的操作内容；

在功能机制上：binlog 日志没有 crash-safe 的能力，只能用于归档，而 redo log 有 crash-safe 能力；

### undo log
Undo Log（回滚日志）是数据库引擎实现事务及多版本并发控制的核心模块，它主要用于记录事务执行过程中对数据的修改，其主要作用包括：

1. **事务回滚：** Undo Log 记录了事务执行过程中数据修改（包括插入、更新、删除等操作）的前后状态。当事务需要回滚时，系统可以根据 Undo Log 的信息将数据恢复到事务开始之前的状态。

2. **多版本并发控制（MVCC）：** MySQL使用 Undo Log 来实现多版本并发控制。当一个事务开始时，它可能会读取某些数据，而其他事务可能在此之后修改了这些数据。Undo Log 记录了事务开始时数据的版本，从而支持读取一致性的查询。

3. **事务的隔离级别：** Undo Log 也用于支持事务的隔离级别，例如可重复读隔离级别。通过保存事务开始时的数据版本，可以确保在整个事务执行期间看到一致的数据视图。

4. **崩溃恢复：** Undo Log 在数据库崩溃后，用于回滚未提交的事务，并确保数据库在崩溃后可以恢复到一致的状态。

### relay log
Relay Log 也叫中转日志。在主从复制过程中，从库接收的binlog会被写入中转日志，然后从库会读取并执行中转日志。

<br/>

---
## 缓存
在MySQL中，有两个关键的缓存机制，它们分别是Buffer Pool（缓冲池）和Change Buffer（变更缓冲区）。

### buffer pool
**Buffer Pool（缓冲池）：**
- **作用：** 缓存数据页中的数据，**提高读性能**。
- **工作原理：** 当查询需要读取表或索引的数据时，MySQL首先检查缓冲池中是否存在相应的数据页。如果存在，就直接使用内存中的数据。如果不存在，就从磁盘读取，并在缓冲池中缓存起来，以便之后的访问。
- **优势：** 缓冲池提高了数据库的读取性能，减少了对磁盘的访问，特别是对于经常被查询的数据。

### change buffer
**Change Buffer（变更缓冲区）：**
- **作用：**记录对数据页的修改，**减少随机读的性能消耗**。
- **工作原理：**Change Buffer 主要用于在内存中没有找到数据页的情况下，将对表的修改缓冲下来。但如果数据页已经在缓冲池中，更新可能会直接应用于内存中的数据页，而不需要通过 Change Buffer。
- **优势：** 变更缓冲区的使用可以减少对表的直接修改，从而降低了写入时的磁盘I/O操作。这对于高写入负载的场景下特别有益。

<br/>

---

## join

### 关联算法

#### 1. 嵌套循环连接（Nested Loop Join）：

嵌套循环连接是一种基本的JOIN算法，它使用嵌套循环遍历第一个表的每一行，并查找与之匹配的第二个表的行。这是一种简单但可能效率较低的算法，尤其是当其中一个表很大时。

```sql
SELECT *
FROM table1
JOIN table2 ON table1.column = table2.column;
```

#### 2. 排序合并连接（Merge Join）：

排序合并连接算法首先对两个表按照连接列进行排序，然后通过类似归并排序的方式合并两个有序的表。这种算法对于连接列有索引的情况效果较好。

```sql
SELECT *
FROM table1
JOIN table2 ON table1.column = table2.column
ORDER BY table1.column, table2.column;
```

#### 3. 哈希连接（Hash Join）：

哈希连接算法使用哈希表来存储一个表的连接列，并将另一个表的连接列与之进行匹配。这种算法适用于没有排序索引但内存足够容纳哈希表的情况。

```sql
SELECT *
FROM table1
JOIN table2 ON table1.column = table2.column;
```

#### 4. 索引连接（Index Join）：

索引连接是一种特殊情况，其中一个表的连接列上有索引，而另一个表没有索引。在这种情况下，查询优化器可能选择使用索引连接，将带有索引的表的行映射到另一个表的行。

```sql
SELECT *
FROM table1
JOIN table2 USE INDEX (index_name) ON table1.column = table2.column;
```

#### 5. 自适应连接算法（Adaptive Join）：

MySQL 8.0引入了自适应连接算法，它允许优化器在查询执行过程中动态选择JOIN算法，根据实际情况选择最优的连接策略。这有助于在不同情况下获得更好的性能。

```sql
SELECT *
FROM table1
JOIN table2 ON table1.column = table2.column;
```


<br/>

---

## 优化场景

### 索引优化

### 为什么不使用长事务
在用户层面，连接池容易爆。  
在数据库方面，尝长事务会长时间占据资源，容易导致死锁，回滚日志版本过长，影响其他事务执行效率。  
在主从同步方面，长事务会导致主从同步延迟增高。  

<br/>

---

## 运维场景

### 选错索引

### 无法命中索引

- 索引字段使用了函数：因为函数会破坏索引的有序性，从而导致全表扫描。
- 隐式类型转化：比如查询字段为字符串，但实际查询条件使用的数字，这会导致在实际查询过程中的执行类型转化。
- 隐式编码转化：当两张表使用了不同类型的编码时，实际查询过程中会执行编码类型转化。

### 单次查询很慢

- 无索引：走全表扫描
- 有索引：
    - 没有正确命中索引
    - 索引体积过大
- 存在脏页，数据库需要先刷脏页

### 性能定期抖动

### count(*)会扫描全表

### 删除表后空间不变
以 InnoDB 为例，数据库引擎在删除数据并不会立即释放磁盘空间，而是将删除的数据标记为已删除。以便后续可以复用。

如果需要释放这些删除数据，需要执行 `OPTIMIZE TABLE` 重建表。其原理就是新建一张临时表实现替换。

### 死锁
在并发系统中，出现循环的资源依赖就会导致死锁。在数据库中，就是多个事务相互等待对方释放资源而导致死锁。

### 如何避免死锁
1. 设置事务超时
   - `SET SESSION innodb_lock_wait_timeout = 10;`：这个设置是会话级别的，只对当前会话有效
   - `SET GLOBAL innodb_lock_wait_timeout = 10;`：这个设置是全局的
2. 使用死锁检测机制，他会引入一定性能消耗，当发生死锁时，会主动回滚其中一个事务。


### 主备延迟过大
造成主备延迟过大的可能原因：
1. 备库服务器配置比主库低
2. 备库读压力过大
3. 存在大事务，导致延迟增大

解决方案：
1. 升级备库服务器配置
2. 一般备库是单线程回放binlog，当主库业务压力较大时，备库延迟不可避免会上升。这时备库也已启用并行复制。
- 按库并行
- 按表并行
- 按行并行


<br/>

---

## 名词解释

### 脏页
脏页（Dirty Page）是指缓冲池中的页（Page）被修改过但尚未写回到磁盘的状态。
缓冲池是用于暂时存储数据库中的数据页的区域，以提高数据读取和写入的性能。
该页被称为“脏页”，因为它在内存中的内容与磁盘上的对应数据不同。

### 主备延迟

<br/>

---

## 开放话题

### 列举一些你的数据库优化经验

优化数据库，需要先知道数据库瓶颈在哪里。其实很多问题都可以通过升级数据库配置解决。

比如硬件方面可以升级SSD、升级服务器配置，软件方面可以调大整缓冲区、连接池等。在大多数普通场景中，这往往是最简单有效的方式。

在一些特殊场景，比如高并发、高查询、高写入等场景，这些特殊场景往往都需要从架构层面去解决根本问题。

数据库层的优化肯定是很重要的，但可能不是核心。

数据库优化的点其实很多：

第一个优化点就是SQL本身。我遇到过直接用SQL写业务的项目，洋洋洒洒仅100行的SQL，各种子查询，各种关联查询。正常情况下我肯是不会去碰它的，但让速度太慢，严重影响业务了。
我当时的做法就是拉通业务方，重新梳理清楚了需求，把业务逻辑放在代码里，尽量精简SQL。

第二个优化点就是索引。这种一般是按业务场景，去选择更合适的索引。    
对于一些范围查询、排序场景，可以考虑使用B+树索引。  
对于一些纯等值查询的场景，可以考虑使用哈希索引。    
对于一些高频的多列查询，可以考虑使用复合索引，通过索引覆盖减少回表次数从而提高查询性能，同时也可以减少索引数量和体积。  
对于一些长字符串的场景，可以适当考虑前缀索引。  

第三个优化其实就是我们常说的读写分离、分库分表。  
以分表来说，我遇到过一个url运营场景。运营数据具有延迟性。一天的数据量都是千万级。每天按时间建一张表，这张表是没有索引的。因为索引影响写入性能。
然后凌晨跑一个定时任务，把昨天的表建一个索引。

还有一个场景，也是我上一位领导留下来的。对MD5的优化。字符串长度是32，大小就是32字节。
但是，你把他转化16进制，它大小就只有16字节。而且完美解决了大小问题。
