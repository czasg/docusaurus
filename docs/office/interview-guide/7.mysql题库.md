---
title: MySQL 题库
sidebar_label: MySQL 题库
slug: mysql
description: 收录MySQL常见面试题库
---

## 1.MySQL基础

### 数据库设计三大范式
数据库设计的三大范式是一组设计原则。

- 第一范式（1NF）：要求原子性
  - 举例：除了主键之外，其他字段数据一样，这种就不满足第一范式
- 第二范式（2NF）：要求非主键字段与主键之间不允许部分依赖
  - 举例：主要针对联合主键场景，非主键字段仅依赖联合主键其中一个字段，这种就不满足第二范式
- 第三范式（3NF）：要求非主键字段与主键之间不允许传递依赖
  - 举例：假设存在书籍和发版社两张表。因为书籍和发版社是存在关联的，现在把他们放在一张表里，那么就会存在传递依赖的关系。

```sql title="不满足范式一，1和3不符合原子性"
| BookID | Title                  | Author                | PublicationDate | Publisher           |
|--------|------------------------|-----------------------|-----------------|---------------------|
| 1      | "The Great Gatsby"     | "F. Scott Fitzgerald" | 1925            | "Scribner"          |
| 2      | "Pride and Prejudice"  | "Jane Austen"         | 1813            | "Penguin Classics"  |
| 3      | "The Great Gatsby"     | "F. Scott Fitzgerald" | 1925            | "Scribner"          |
```

```sql title="不满足范式二，一般存在于联合主键场景，导致部分依赖"
| StudentID | CourseID | CourseName         | Teacher          |
|----------|----------|--------------------|-------------------|
| 1        | 101      | "Mathematics 101"  | "Mr. Smith"       |
| 1        | 102      | "Physics 101"      | "Ms. Johnson"     |
| 2        | 101      | "Mathematics 101"  | "Mr. Smith"       |
| 2        | 103      | "Chemistry 101"    | "Dr. Brown"       |
```

```sql title="不满足范式三，存在传递依赖，应该拆表"
| BookID | Title                  | Author                | PublicationDate | Publisher           |
|--------|------------------------|-----------------------|-----------------|---------------------|
| 1      | "The Great Gatsby"     | "F. Scott Fitzgerald" | 1925            | "Scribner"          |
| 2      | "Pride and Prejudice"  | "Jane Austen"         | 1813            | "Penguin Classics"  |
| 3      | "The Great Gatsby"     | "F. Scott Fitzgerald" | 1925            | "Scribner"          |
```

### 服务层组成
- 连接器：负责建立用户连接，初始化权限，管理连接
- 查询缓存
- 分析器：词法解析
- 优化器：基于索引所化查询
- 执行器：调用引擎层接口操作数据

### 一条SQL的执行过程

在 MySQL 中，一条完整 SQL 的执行过程大致是：

- 建立连接：MySQL 连接器负责建立用户连接，包括初始化用户权限等基础信息。
- 查询缓存：对于已经存在缓存的查询语句，MySQL 会直接返回缓存结果。
- 语法分析：MySQL 会对 SQL 进行解析并检查是否存在语法错误。
- 查询优化：一条 SQL 的执行策略是多样的，比如可以走全表扫描，或者走某个索引等。
  此处的查询优化就是根据表的大小、索引等信息，再结合 SQL 的查询条件，综合选择最优查询方案。
- 执行语句：MySQL 的数据操作是基于存储引擎实现的。此处的执行是调用存储引擎接口实现。


<br/>

---

## 2.MySQL存储引擎

### 介绍下常见的存储引擎

MySQL 是一个开源关系型数据库管理系统，支持多种不同的存储引擎。

存储引擎是 MySQL 用于管理数据的基础组件，它们负责处理 SQL 语句，包括读取和写入数据等操作。
常见的存储引擎有：

- InnoDB：InnoDB 是 MySQL 默认的存储引擎，它支持事务、外键和行级锁等特性。
- MyISAM：MyISAM 是 MySQL 最古老的存储引擎之一，不支持事务和行级锁，这也是它被 InnoDB 取代的很大一部分原因之一。
  但它非常适合用于处理大量的读取操作，例如数据仓库和日志文件等。
- Memory：Memory 存储引擎将内存存储引擎，优点是速度非常快，缺点就是数据是非持久的。

---

### 介绍下InnoDB与MyISAM区别

InnoDB和MyISAM是两个常用的存储引擎，用于MySQL数据库管理系统，它们在功能、性能和适用场景上有一些重要的区别。以下是它们之间的主要区别：

1. **事务支持：**InnoDB支持事务（ACID属性），MyISAM不支持事务

2. **锁机制：**InnoDB使用行级锁（row-level locking），MyISAM使用表级锁（table-level locking）

3. **外键支持：**
    - InnoDB支持外键完整性约束，可以定义外键关系，确保数据的完整性。
    - MyISAM不支持外键，不能定义外键关系。

4. **崩溃恢复：**
    - InnoDB支持崩溃恢复，具有事务日志和事务回滚功能，可以更好地处理数据库崩溃时的数据完整性。
    - MyISAM不具备崩溃恢复功能，容易在崩溃时丢失数据。

6. **空间和性能：**
    - InnoDB通常需要更多的磁盘空间来存储数据，因为它维护额外的事务日志和索引结构。
    - MyISAM在一些情况下可能在性能上表现更好，特别是在只读操作较多的情况下。

<br/>

---

## 3.MySQL事务

### 什么是事务

事务是一组数据库操作的逻辑单元。这些操作要么全部成功，要么全部失败。因此它具有ACID属性：

1. **原子性（Atomicity）**：事务是原子的，意味着它要么完全执行，要么不执行。如果事务的任何部分失败，整个事务将被回滚，数据库将恢复到事务开始之前的状态，以确保数据的一致性。

2. **一致性（Consistency）**：事务的执行将数据库从一个一致状态转移到另一个一致状态。这意味着事务的执行不会破坏数据库的完整性约束或数据关系。

3. **隔离性（Isolation）**：每个事务应该在不受其他事务干扰的情况下执行，即使多个事务同时运行也不会相互干扰。这意味着事务之间应该是相互隔离的，以防止数据冲突。

4. **持久性（Durability）**：一旦事务成功提交，其结果应该是永久性的，并且在系统故障或重启后仍然保持。这要求数据库将事务的变更持久地保存在存储设备上，以确保数据的持久性。

### 事务隔离级别

MySQL 是一个关系型数据库管理系统，它支持多个事务之间的并发执行。因此需要保障事务之间的隔离性和数据一致性。

MySQL 提供了四个事务隔离级别，它们分别是：

- READ UNCOMMITTED（读未提交）：最低级别的隔离级别。事务可以读取另一个事务尚未提交的数据。在此隔离级别下，会存在脏读、不可重复读和幻读等问题。
- READ COMMITTED（读已提交）：默认的隔离级别。事务只能读取另一个已提交的事务的数据。在此隔离级别下，解决了脏读的问题，但仍然存在不可重复读、幻读的问题。
- REPEATABLE READ（可重复读）：事务开始时读取的数据集合将保持不变，即使其他事务对这些数据进行了修改或插入操作，也不会影响该事务。这种隔离级别解决了不可重复读的问题，但是仍然存在幻读问题。
- SERIALIZABLE（序列化）：最高级别的隔离级别，多个事务之间顺序执行。在此隔离级别下，事务之间不会存在冲突，但会牺牲性能。

### 什么是脏读

当一个事务可以读取另一个事务尚未提交的数据，而另一个事务随后被回滚，那么当前事务读取到的数据就是无效的。

这类现象被称之为**脏读（Dirty read）**，因为它读到了脏数据。

### 什么是不可重复读

**不可重复读**是指，当一个事务，在某个时间段内，多次读取同一行数据，出现的数据不一致的场景。

不可重复读是数据库隔离级别中的一种问题，常在读未提交、读已提交隔离级别中发生。

不可重复读与幻读的区别在于，不可重复读关注的是同一行数据在一个事务内的两次读取之间是否一致，
而幻读关注的是两次查询的结果集的行数是否一致。

### 什么是幻读

**幻读**是指，当一个事务中，在某个时间段内，多次执行同一个范围查询结果集时，出现的数据不一致的场景。

幻读是数据库隔离级别中的一种问题，常发生于范围查询场景。在可重复读隔离级别下是比较常见的。

#### 如何避免幻读

1. 使用更严格的序列化事务隔离级别。但会带来较大的性能损耗。
2. 使用行锁和间隙锁。通过在SQL语句中使用 `FOR UPDATE` 实现。
   - `FOR UPDATE NOWAIT`：如果无法获得锁，立即返回而不是等待
   - `FOR UPDATE SKIP LOCKED`：如果无法获得锁，跳过而不是等待
3. 在应用层实现乐观锁，每次执行语句时去检查一遍。



---

### MVCC
多版本并发控制（MVCC）是一种数据库事务并发控制的机制，其实现原理主要涉及**版本号的管理**，
以及对数据的**读取和写入时的一致性处理**（基于ReadView决定事务可以看到那些数据版本）。

以下是MySQL的MVCC实现原理的主要步骤：

1. **版本号分配：** 每个事务都被分配一个唯一的事务标识（Transaction ID）。对于每个被修改的数据行，都会为其分配一个版本号，通常是事务的ID。这个版本号会标记数据行的状态，指示数据行的修改历史。

2. **Read View：** 在启动事务时，会生成一个Read View，包含当前事务的事务ID。Read View决定了事务能够看到哪些数据版本。Read View的生成可能包括一些额外的信息，例如事务启动时的系统版本号。

3. **Read操作：** 当一个事务执行读操作时，系统会使用Read View来判断当前事务能够看到哪些数据版本。只有那些版本号早于或等于Read View的数据版本才能被当前事务读取。这确保了事务读取的数据是一致的，不受其他并发事务修改的影响。

4. **Write操作：** 当一个事务执行写操作时，会在数据行上创建一个新的版本。新版本的版本号是事务的ID。原始数据行的版本号被更新为新版本的版本号。这样，新版本的数据行对于新的读操作是可见的，而对于旧的Read View是不可见的。

5. **回滚和垃圾回收：** 当一个事务被回滚时，相关的修改可以被丢弃，不会影响其他事务。定期执行垃圾回收操作来删除不再需要的旧版本数据，以释放存储空间。


<br/>

---

## MySQL索引

### 你了解的索引种类

MySQL支持多种类型的索引，以提高查询性能和加速数据检索。以下是一些常见的MySQL索引类型：

1. **B-树索引（B-Tree Index）：** B-树索引是最常见的索引类型，在大多数情况下都可以满足需求。它适用于精确匹配和范围查询。B-树索引适用于整数、字符、日期等数据类型。

2. **哈希索引（Hash Index）：** 哈希索引将索引键的值经过哈希函数计算后存储在索引中，用于加速等值查询。它对于等值查询非常高效，但不支持范围查询或排序操作。哈希索引适用于大多数数据类型，但特别适合于高基数列。

3. **全文索引（Full-Text Index）：** 全文索引用于对文本数据进行全文搜索。它允许模糊匹配、词干搜索和布尔搜索。全文索引适用于TEXT和VARCHAR列。

4. **空间索引（Spatial Index）：** 空间索引用于处理地理信息系统（GIS）数据，如地理坐标、多边形等。它可以加速地理空间查询，如点在多边形内的查询。

5. **前缀索引（Prefix Index）：** 前缀索引是对列值的前缀进行索引，而不是整个值。它可以用于节省索引存储空间和加速检索。前缀索引适用于较长的字符串列。

6. **复合索引（Composite Index）：** 复合索引是包含多个列的索引。它可以用于加速多列查询，但要注意索引顺序和查询条件的匹配性，以确保性能提升。

7. **唯一索引（Unique Index）：** 唯一索引要求索引列的值在表中是唯一的，用于强制数据的唯一性。它适用于任何数据类型。

8. **主键索引（Primary Key Index）：** 主键索引是唯一索引的一种，通常用于标识表中的每一行。它确保每行都具有唯一的主键值。

9. **外键索引（Foreign Key Index）：** 外键索引用于连接不同表格之间的关系。它通常与外键约束一起使用，以确保数据完整性。

10. **全局索引（Clustered Index）：** 全局索引用于InnoDB存储引擎，它决定了数据行在表中的物理存储顺序。每个InnoDB表只能有一个全局索引。

---

### 如何理解块索引

通常来说，块索引（Block Index）不是一个独立的索引类型，而是一个较低级别的概念，
用于描述数据库引擎内部索引结构的存储方式。

但在PostgreSQL中，块索引是一个高级特性。
它通常用于特定类型的应用场景，特别是那些需要处理大量块级别数据的场景，例如时间序列数据库或列式数据库。
它支持以下特性：

1. **范围查询（Range Queries）**：块索引可用于支持范围查询，例如查找某个范围内的数据块。这对于处理时间序列数据等应用非常有用。

2. **块级别的检索**：块索引直接在数据块级别存储索引信息，从而可以加速块级别的检索，而不是单个行级别的检索。

3. **块合并和块分割**：块索引对于块合并（Block Merging）和块分割（Block Splitting）等操作非常高效，这些操作通常用于数据块的管理。

---

### 主键和外键的区别

主键可以作为每一行数据的唯一性标识。
外键则是用于维护数据完整性和建立表格之间关系的一种强约束。

### 最左前缀原则

### 无法命中索引的情况

### 读写分离和分库分表

### char和varchar区别

- CHAR 是一种固定长度的字符数据类型
- VARCHAR 是一种可变长度的字符数据类型

<br/>

---

## 日志

### 什么是 WAL
WAL 是 Write-Ahead Logging 的简写。是一种预写日志技术。它主要有两个作用：
- crash safe（崩溃恢复）：它记录在数据库引擎层面发生的事务修改，当数据库发生故障时，可以通过重新 redo log 来将数据库恢复到一致的状态。
- 将随机写转化为顺序写：

### redo log
Redo Log 是一种崩溃恢复的机制，它记录在数据库引擎层面发生的事务修改，当数据库发生故障时，可以通过重新 redo log 来将数据库恢复到一致的状态。

```text title="redo log 记录数据页的物理修改"
Transaction ID: 123
LSN: 456
Page ID: employees_page_102
Modification Type: UPDATE
Modified Data: 
  - Employee ID: 102
  - New Salary: 20000
```

此外，redo log 将随机写转化为顺序写，具体过程如下：

1. 用户或应用程序发起一个事务。
2. 在事务执行过程中，相关的数据修改操作首先被写入数据库表中，修改了内存中的数据。
3. 同时，相应的 Redo Log 记录会被生成并写入 Redo Log 文件。这些记录包含了已经对数据表进行的物理修改。
4. 当事务顺利完成，用户或应用程序执行提交操作。

### binlog
binlog 全称 Binary Log（二进制日志），是 MySQL 用于记录数据库更改的一种日志文件。
它包含了对数据库进行修改的所有信息，例如插入、更新、删除等操作。常用于**主从复制**和**数据恢复**。

1. **记录格式：**
   - **Statement**：记录原生的SQL语句
   - **Row**：记录具体修改的数据
   - **Mixed**：基于Statement和Row，对于可能造成数据不一致的场景选择Row，否则选择Statement

2. **作用：**
    - **主从复制：** Binlog是MySQL主从复制的核心。主数据库记录所有的变更，而从数据库通过读取binlog实现与主数据库的同步。
    - **数据恢复：** Binlog可以用于恢复数据库到之前的状态，从而避免数据丢失。
    - **数据库备份：** Binlog可以与数据库快照结合，用于创建一致性的备份。

### binlog日志格式
binlog 主要有三种：

1. **Statement-Based Replication (SBR):**
    - **工作原理：** 这种格式记录的是SQL语句，即在主服务器上执行的SQL语句。当在主服务器上执行一个SQL语句时，这个语句会被记录到binlog中，而从服务器会读取这个binlog，并在从服务器上执行相同的SQL语句。
    - **优点：** 相对较小的日志文件大小，因为只需记录SQL语句。
    - **缺点：** 由于是基于语句的，可能会出现在主从服务器上执行相同SQL语句时导致的不一致性问题。例如，由于数据不同步或随机因素导致的不同结果。

2. **Row-Based Replication (RBR):**
    - **工作原理：** 这种格式记录的是对表中行的实际更改。当在主服务器上进行数据更改时，binlog会记录哪些行受到了影响，以及发生了什么变化。而从服务器会根据这些变化来修改对应的数据行。
    - **优点：** 更加精确，可以确保主从服务器的数据一致性。
    - **缺点：** 相对较大的日志文件大小，因为需要记录更详细的信息。

3. **Mixed Format:**
    - **工作原理：** 这是SBR和RBR的混合格式。MySQL会根据执行的具体操作选择使用SBR还是RBR。
    - **优点：** 兼顾了SBR和RBR的优点，既可以减小日志文件大小，又可以保持数据的一致性。
    - **缺点：** 需要更多的判断和逻辑来确定使用哪种格式，可能会增加一些复杂性。

```sql title="statement 和 row 对比"
-- SQL语句
UPDATE employees SET salary = salary * 1.1 WHERE department_id = 2;

-- 对应的binlog记录（SBR）
### UPDATE `employees` SET `salary` = `salary` * 1.1 WHERE `department_id` = 2;

-- 对应的binlog记录（RBR）
### UPDATE `employees` SET `salary` = 22000 WHERE `employee_id` = 101;
### UPDATE `employees` SET `salary` = 19800 WHERE `employee_id` = 102;
### UPDATE `employees` SET `salary` = 24200 WHERE `employee_id` = 103;
```

### undo log
Undo Log（回滚日志）是数据库引擎实现事务及多版本并发控制的核心模块，它主要用于记录事务执行过程中对数据的修改，其主要作用包括：

1. **事务回滚：** Undo Log 记录了事务执行过程中数据修改（包括插入、更新、删除等操作）的前后状态。当事务需要回滚时，系统可以根据 Undo Log 的信息将数据恢复到事务开始之前的状态。

2. **多版本并发控制（MVCC）：** MySQL使用 Undo Log 来实现多版本并发控制。当一个事务开始时，它可能会读取某些数据，而其他事务可能在此之后修改了这些数据。Undo Log 记录了事务开始时数据的版本，从而支持读取一致性的查询。

3. **事务的隔离级别：** Undo Log 也用于支持事务的隔离级别，例如可重复读隔离级别。通过保存事务开始时的数据版本，可以确保在整个事务执行期间看到一致的数据视图。

4. **崩溃恢复：** Undo Log 在数据库崩溃后，用于回滚未提交的事务，并确保数据库在崩溃后可以恢复到一致的状态。

### relay log
Relay Log 也叫中转日志。在主从复制过程中，从库接收的binlog会被写入中转日志，然后从库会读取并执行中转日志。


---
## 缓存
在MySQL中，有两个关键的缓存机制，它们分别是Buffer Pool（缓冲池）和Change Buffer（变更缓冲区）。

### buffer pool
**Buffer Pool（缓冲池）：**
- **作用：** 缓存数据页中的数据，**提高读性能**。
- **工作原理：** 当查询需要读取表或索引的数据时，MySQL首先检查缓冲池中是否存在相应的数据页。如果存在，就直接使用内存中的数据。如果不存在，就从磁盘读取，并在缓冲池中缓存起来，以便之后的访问。
- **优势：** 缓冲池提高了数据库的读取性能，减少了对磁盘的访问，特别是对于经常被查询的数据。

### change buffer
**Change Buffer（变更缓冲区）：**
- **作用：**记录对数据页的修改，**减少随机读的性能消耗**。
- **工作原理：**Change Buffer 主要用于在内存中没有找到数据页的情况下，将对表的修改缓冲下来。但如果数据页已经在缓冲池中，更新可能会直接应用于内存中的数据页，而不需要通过 Change Buffer。
- **优势：** 变更缓冲区的使用可以减少对表的直接修改，从而降低了写入时的磁盘I/O操作。这对于高写入负载的场景下特别有益。

<br/>

---

## 优化场景

### 索引优化

<br/>

---

## 运维场景

### 选错索引

### 无法命中索引

- 索引字段使用了函数：因为函数会破坏索引的有序性，从而导致全表扫描。
- 隐式类型转化：比如查询字段为字符串，但实际查询条件使用的数字，这会导致在实际查询过程中的执行类型转化。
- 隐式编码转化：当两张表使用了不同类型的编码时，实际查询过程中会执行编码类型转化。

### 单次查询很慢

- 无索引：走全表扫描
- 有索引：
    - 没有正确命中索引
    - 索引体积过大
- 存在脏页，数据库需要先刷脏页

### 性能定期抖动

### count(*)会扫描全表

### 删除表后空间不变
以 InnoDB 为例，数据库引擎在删除数据并不会立即释放磁盘空间，而是将删除的数据标记为已删除。以便后续可以复用。

如果需要释放这些删除数据，需要执行 `OPTIMIZE TABLE` 重建表。其原理就是新建一张临时表实现替换。

### 死锁
在并发系统中，出现循环的资源依赖就会导致死锁。在数据库中，就是多个事务相互等待对方释放资源而导致死锁。

### 如何避免死锁
1. 设置事务超时
   - `SET SESSION innodb_lock_wait_timeout = 10;`：这个设置是会话级别的，只对当前会话有效
   - `SET GLOBAL innodb_lock_wait_timeout = 10;`：这个设置是全局的
2. 使用死锁检测机制，他会引入一定性能消耗，当发生死锁时，会主动回滚其中一个事务。


### 主备延迟过大
造成主备延迟过大的可能原因：
1. 备库服务器配置比主库低
2. 备库读压力过大
3. 存在大事务，导致延迟增大

解决方案：
1. 升级备库服务器配置
2. 一般备库是单线程回放binlog，当主库业务压力较大时，备库延迟不可避免会上升。这时备库也已启用并行复制。
- 按库并行
- 按表并行
- 按行并行


<br/>

---

## 名词解释

### 脏页
脏页（Dirty Page）是指缓冲池中的页（Page）被修改过但尚未写回到磁盘的状态。
缓冲池是用于暂时存储数据库中的数据页的区域，以提高数据读取和写入的性能。
该页被称为“脏页”，因为它在内存中的内容与磁盘上的对应数据不同。

### 主备延迟

<br/>

---

## 开放话题

### 列举一些你的数据库优化经验

索引优化
场景1：
优化前
字段名：K
字段类型：text
数据量级：17亿
索引体积：70G
17亿数据，字段：k
优化后：
索引体积：60G
优化方案：btree索引改hash索引、字符串转
索引体积：30G

覆盖索引：样本类型查询接口，sample_hash和sample_type两个字段，查询效率更稳定了
