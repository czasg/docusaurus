<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Czasg Blog</title>
        <link>https://czasg.github.io/docusaurus/blog</link>
        <description>Czasg Blog</description>
        <lastBuildDate>Mon, 13 Dec 2021 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[基于 gRPC 实现负载均衡]]></title>
            <link>https://czasg.github.io/docusaurus/blog/2021/12/13/gRPC负载均衡</link>
            <guid>基于 gRPC 实现负载均衡</guid>
            <pubDate>Mon, 13 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[本文主要介绍在 k8s 环境下 gRPC 负载均衡的具体实现。]]></description>
            <content:encoded><![CDATA[<p>本文主要介绍在 k8s 环境下 gRPC 负载均衡的具体实现。</p><h2>概述</h2><p>我们的服务最初使用 <code>DaemonSet</code> 部署在 k8s 上，即单台宿主机仅运行一个 <code>Pod</code>，然后通过 <code>NodePort Service</code> 的方式对外暴露服务。</p><p>在这种场景下直接对外暴露 IP 提供服务，所以也不存在负载均衡的说法。</p><p>现在服务改造升级，以前的 <code>DaemontSet</code> 类型升级为 <code>Deployment</code> 类型，而 <code>NodePort Service</code> 类型则升级为 <code>ClusterIP Service</code> 类型。</p><p>单副本的场景基本没有任何区别，但是在多副本的场景下，却发生了流量倾斜，具体表现就是某个副本的压力非常高，而其他副本的压力很小，进而导致服务整体异常。</p><blockquote><p>简单分析:  </p><p>gRPC 是基于 HTTP2.0 实现的长连接，且默认没有超时，那么再回到上述场景，显然就是客户端与某个具体的副本建立了长连接<br/>
<!-- -->而连接又不会断开，导致了请求流量倾斜的问题。</p></blockquote><p>经过分析，我们也可以大致了解了问题，长连接基于TCP建立连接后，不会断开。
所以常规的基于七层的负载均衡方法，无法为长连接提供有效负载。</p><p>具体解决的方法有多种，我们将其分为：  </p><ul><li>用户侧的负载均衡</li><li>服务侧的负载均衡</li></ul><h2>gRPC 负载均衡 - 用户侧</h2><h3>Headless Service</h3><p>k8s 的 <code>Service</code> 是一个
<code>ClusterIP Service</code></p><h3>KubeResolver</h3><h2>gRPC 负载均衡 - 服务侧</h2><h3>长连接转短连接</h3><h3>中间件</h3>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Github 搭建 Docusaurus 站点]]></title>
            <link>https://czasg.github.io/docusaurus/blog/2021/12/3/Github搭建Docusaurus站点</link>
            <guid>Github 搭建 Docusaurus 站点</guid>
            <pubDate>Fri, 03 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[1、新建 Github 仓库]]></description>
            <content:encoded><![CDATA[<h2>1、新建 Github 仓库</h2><p>首先，登录<a href="https://github.com/new">Github仓库创建页面</a>，我们创建一个全新的空白仓库，项目名命名为 <code>testDocusaurus</code>。</p><p>然后通过 <code>git</code> 将仓库拉取到本地，至此，我们拥有了一个全新的空白仓库 <code>testDocusaurus</code>。  </p><p><img src="gitindex.png"/></p><h2>2、初始化 Docusaurus 项目</h2><blockquote><p><a href="https://docusaurus.io/zh-CN/docs/installation">Docusaurus项目初始化细节请参考官方文档</a></p></blockquote><p>进入到仓库 <code>testDocusaurus</code> 所在的空白目录，并在此目录打开终端界面。</p><p>为了更好的完成接下来的步骤，你可能需要预先安装<strong>nodejs</strong>。在此，假设你已经准备完毕。<br/>
<!-- -->那我们接下来通过以下指令初始化一个 <code>Docusaurus</code> 项目。</p><pre><code class="language-shell" metastring="script">&gt;&gt;&gt; npx create-docusaurus@latest website classic
...
...
Successfully created &quot;website&quot;.
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles your website into static files for production.

  npm run serve
    Serves the built website locally.

  npm deploy
    Publishes the website to GitHub pages.

We recommend that you begin by typing:

  cd website
  npm start

Happy building awesome websites!
</code></pre><p>该指令运行完后，会输出一些简单的运行指令，而且我们应该可以看到一个 <code>website</code> 的目录，我们先将里面的内容剪贴出来，放到我们空白仓库目录下面。</p><p>此时，我们按照提示，运行 <code>npm start</code> 指令，我们就可以运行此项目。</p><p>通常启动端口为3000，则默认路径为：http://localhost:3000/  </p><p><img src="websiteindex.png"/></p><h2>3、搭建 Github Actions</h2><blockquote><p>Github Actions部署细节参考<a href="https://docusaurus.io/zh-CN/docs/deployment#deploying-to-github-pages">官方文档</a></p></blockquote><p>接入 <code>Github Actions</code> 需要创建一对新的 <strong>SSH Key</strong>，并将公钥和密钥均配置到 Github，我们来具体看下操作。</p><p>首先创建密钥，我们可以指定一个新的目录，然后得到公钥（id_rsa.pub）和私钥（id_rsa）</p><pre><code class="language-shell" metastring="script">&gt;&gt;&gt; ssh-keygen -t rsa -C &quot;email&quot;
...
...
The key&#x27;s randomart image is:
+---[RSA 3072]----+
| .=oo*=o=o.      |
| o+.=o==.o       |
|  .O.O=+o        |
|  ..=o@.oo       |
| . o +.+S+..     |
|  . + . E.o      |
|   o . .         |
|  .              |
|                 |
+----[SHA256]-----+
</code></pre><p>我们打开仓库的 <code>deploy keys</code>，选择新增，将 <code>id_rsa.pub</code> 中的内容复制进去，并选中 <code>Allow write access</code> 框，表示赋予部署写权限。
<img src="deploykey.png"/></p><p>此时部署公钥已经完成，我们再将私钥也配置上。打开同级配置下的 Secret，选择新增密钥，
我们将私钥内容复制到 <code>Value</code> 中，而 <code>Name</code> 填写 <code>GH_PAGES_DEPLOY</code> 即可。</p><p>最后，我们创建 <code>Github Actions</code>，将模板复制进去，则整个流水线就已经配置好了。复制时，将对应的基础配置改下即可，如下：</p><pre><code class="language-shell" metastring="script">git config --global user.email &quot;email&quot;
git config --global user.name &quot;name&quot;
</code></pre><p>这里的 <code>email</code> 需要是 github 配置的 email，而 <code>name</code> 则是 github 用户名。</p><h2>4、更新仓库，尝试自动部署</h2><p>确保 Github Pages 已经初始化好，那么我们往仓库推送修改时，就可以触发自动部署了。</p>]]></content:encoded>
        </item>
    </channel>
</rss>