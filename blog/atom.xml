<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://czasg.github.io/docusaurus/blog</id>
    <title>Czasg Blog</title>
    <updated>2022-03-01T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://czasg.github.io/docusaurus/blog"/>
    <subtitle>Czasg Blog</subtitle>
    <icon>https://czasg.github.io/docusaurus/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[数据库常用操作]]></title>
        <id>数据库常用操作</id>
        <link href="https://czasg.github.io/docusaurus/blog/2022/3/1/数据库常用操作"/>
        <updated>2022-03-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[摘要在此处]]></summary>
        <content type="html"><![CDATA[<p>摘要在此处</p><p>正文在此处</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg
<strong>版权声明:</strong> 转载请注明出处哦~👮‍
:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库是否适合容器化部署]]></title>
        <id>数据库是否适合容器化部署</id>
        <link href="https://czasg.github.io/docusaurus/blog/2022/2/22/数据库是否适合容器化部署"/>
        <updated>2022-02-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[随着 Kubernetes 的流行，越来越来的应用被打包成镜像，作为容器部署在 k8s 上。]]></summary>
        <content type="html"><![CDATA[<p>随着 Kubernetes 的流行，越来越来的应用被打包成镜像，作为容器部署在 k8s 上。</p><p>在 k8s 中，pod 是最小的部署单位，内部可以包含多个容器镜像，每一个 pod 都具有有限的生命周期。<br/>
<!-- -->对于无状态服务来说，特别适合在 k8s 上运行，因为无状态服务，是具有弹性的，可以更好的应对 pod 扩缩容、重启等特性。<br/>
<!-- -->相反，对于有状态服务（类似数据库等），则存在一定的瓶颈限制。</p><p>先来看下 k8s 如何部署有状态服务，然后讨论下其优缺点。</p><h2>DaemonSet &amp; StatefulSet</h2><p><strong>DaemonSet</strong> 是 k8s 的控制器资源对象之一，其特点是：   </p><blockquote><p>1、确保每个节点仅启动一个 pod 副本，当有新节点加入集群时，自动为其增加一个 pod。</p></blockquote><p>比较典型的是日志收集服务，比如：我们需要确保每个节点上起一个 <code>logstash</code>，以便回收节点上的服务日志。  </p><p>数据库服务可以在类似场景下使用，比如给某个节点打上标签，确保某个数据库在对应节点上以 DaemonSet 类型启动，这样就可以确保该节点仅有一个 pod 副本。
最后通过 <code>nodeport</code> 的方式对外提供服务。
此时我们的数据库就拥有了稳定的节点 ip 和本地存储。  </p><p>但是这种方式，和直接在物理机上部署的方式差别不大，主要是复用了 k8s 的管理能力。</p><p><strong>StatefulSet</strong> 是 k8s 专为有状态服务设计的资源类型，它拥有：  </p><blockquote><p>1、稳定的网络标识：当服务重启，pod 绑定的 ip 不会变化，但是手动删除或者重建副本时，会重新分配 ip。
创建 headless service 时可以通过 <code>${serviceName-number}.${service}.${namespace}</code> 访问指定 pod。<br/>
<!-- -->2、稳定的持久存储：基于 pvc 实现，每个 pod 会绑定专有的 pvc 存储。<br/>
<!-- -->3、有序的扩缩容：会安装顺序从 0 逐一启动或者重建，此时类似滚动更新的扩容策略不在适用。      </p></blockquote><p>当我们的数据库服务部署 k8s 上时，可以选择 StatefulSet 资源类型。<br/>
<!-- -->它的基本特点，足够支持一个有状态服务的正常运转。</p><h2>性能瓶颈</h2><p>数据库主要是和存储打交道，其性能瓶颈通常在磁盘IO。<br/>
<!-- -->那么快速的磁盘IO，将有助于提升数据库的性能和吞吐量。<br/>
<!-- -->比如：分别部署在 HDD 和 SSD 上的两个数据库，在相同其他条件下，SSD 上的数据库肯定拥有更高的性能。 </p><p>当我们的数据库部署在 k8s 上时，可以通过挂载卷 volume（nfs、ceph）持久化数据，但是这样就不可避免的引入了网络IO，在本身就拉跨的瓶颈上又补一刀。<br/>
<!-- -->所以当我们使用 k8s 部署数据库时，可能需要重点考虑下性能问题。</p><p>除了 nfs、ceph 之外，还有 hostpath 这类本地存储，可以忽略网络影响。
但是这需要我们的副本绑定到固定的节点上，此时就走的类似 DaemonSet 的部署路线了。</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍
:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于副业的一些思考]]></title>
        <id>关于副业的一些思考</id>
        <link href="https://czasg.github.io/docusaurus/blog/2022/2/21/关于副业的一些思考"/>
        <updated>2022-02-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[摘要在此处]]></summary>
        <content type="html"><![CDATA[<p>摘要在此处</p><p>正文在此处</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍
:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[golang升级导致goland不可用]]></title>
        <id>golang升级导致goland不可用</id>
        <link href="https://czasg.github.io/docusaurus/blog/2022/2/17/golang升级导致goland不可用"/>
        <updated>2022-02-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[go1.14.1 升级至 go1.17.7，导致 goland 打开后显示无法找到 GOROOT。]]></summary>
        <content type="html"><![CDATA[<p>go1.14.1 升级至 go1.17.7，导致 goland 打开后显示无法找到 GOROOT。</p><p>错误显示：</p><pre><code class="language-text">The selected directory is not a valid home for Go SDK
</code></pre><p>通过 go env 查看后发现相关配置无问题，环境变量也无问题。</p><p>最后找的解决方案：
1、go version 查看自己当前版本<br/>
<!-- -->2、编辑 {GOROOT}/src/runtime/internal/sys/zversion.go 文件，写入以下变量</p><pre><code class="language-go">const TheVersion = `go1.17.4`
</code></pre><p>3、重启 goland，然后点击 setroot 即可。  </p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍
:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jmeter及性能测试]]></title>
        <id>Jmeter及性能测试</id>
        <link href="https://czasg.github.io/docusaurus/blog/2022/2/2/Jmeter及性能测试"/>
        <updated>2022-02-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录 jmeter 工具的使用，以及在性能测试过程中学习到的一些知识点。]]></summary>
        <content type="html"><![CDATA[<p>记录 jmeter 工具的使用，以及在性能测试过程中学习到的一些知识点。</p><h2>性能指标</h2><ul><li>TPS（Transactions Per Second）：每秒事务数，吞吐率</li><li>QPS（Queries Per Second）：每秒查询数</li><li>RT（Response Time）：响应时间，服务延迟</li></ul><p>性能问题，归根结底还是资源问题。常见的瓶颈点：<br/>
<!-- -->1、网络IO<br/>
<!-- -->2、存储IO<br/>
<!-- -->3、CPU、内存<br/>
<!-- -->4、应用  </p><h2>jmeter 结果解读</h2><p>并发线程、响应时间、TPS之间的关联：</p><pre><code class="language-text">TPS = (1s/响应时间) * 并发线程
</code></pre><p>:::note
假设有4个线程，每个线程每秒发起4个请求并响应，此时并发是16而非4
:::</p><pre><code class="language-text" metastring="title=&quot;1个线程&quot;" title="&quot;1个线程&quot;">summary +   5922 in 00:00:30 =  197.4/s Avg:     4 Min:     0 Max:    26 Err:     0 (0.00%) Active: 1 Started: 1 Finished: 0
summary =  35463 in 00:03:05 =  192.0/s Avg:     5 Min:     0 Max:   147 Err:     0 (0.00%)
summary +   5922 in 00:00:30 =  197.5/s Avg:     4 Min:     0 Max:    24 Err:     0 (0.00%) Active: 1 Started: 1 Finished: 0
summary =  41385 in 00:03:35 =  192.8/s Avg:     5 Min:     0 Max:   147 Err:     0 (0.00%)
summary +   5808 in 00:00:30 =  193.6/s Avg:     5 Min:     0 Max:    25 Err:     0 (0.00%) Active: 1 Started: 1 Finished: 0
summary =  47193 in 00:04:05 =  192.9/s Avg:     5 Min:     0 Max:   147 Err:     0 (0.00%)
</code></pre><p>(1000ms/5ms)*1=200TPS</p><pre><code class="language-text" metastring="title=&quot;10个线程&quot;" title="&quot;10个线程&quot;">summary +  11742 in 00:00:30 =  391.3/s Avg:    25 Min:     0 Max:   335 Err:     0 (0.00%) Active: 10 Started: 10 Finished: 0
summary =  55761 in 00:02:24 =  386.6/s Avg:    25 Min:     0 Max:   346 Err:     0 (0.00%)
summary +  11924 in 00:00:30 =  397.5/s Avg:    25 Min:     0 Max:    80 Err:     0 (0.00%) Active: 10 Started: 10 Finished: 0
summary =  67685 in 00:02:54 =  388.5/s Avg:    25 Min:     0 Max:   346 Err:     0 (0.00%)
summary +  11884 in 00:00:30 =  396.2/s Avg:    25 Min:     0 Max:   240 Err:     0 (0.00%) Active: 10 Started: 10 Finished: 0
summary =  79569 in 00:03:24 =  389.6/s Avg:    25 Min:     0 Max:   346 Err:     0 (0.00%)
</code></pre><p>(1000ms/25ms)*10=400TPS</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍
:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用 sql 操作]]></title>
        <id>常用 sql 操作</id>
        <link href="https://czasg.github.io/docusaurus/blog/2022/1/20/常用 sql 操作"/>
        <updated>2022-01-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[整理下 sql 常见的操作。]]></summary>
        <content type="html"><![CDATA[<p>整理下 sql 常见的操作。</p><h2>mysql</h2><h2>postgres</h2><h3>建表</h3><pre><code class="language-sql" metastring="title=&quot;创建普通表&quot;" title="&quot;创建普通表&quot;">CREATE TABLE IF NOT EXISTS my_table (
    k  text,
    v  text
)
</code></pre><pre><code class="language-sql" metastring="title=&quot;创建临时表&quot;" title="&quot;创建临时表&quot;">CREATE TEMPORARY TABLE IF NOT EXISTS my_table (
    k  text,
    v  text
) ON COMMIT DROP;
</code></pre><pre><code class="language-sql" metastring="title=&quot;删除表&quot;" title="&quot;删除表&quot;">DROP TABLE IF EXISTS my_table; -- 普通删除
DROP TABLE IF EXISTS my_table CASCADE; -- 级联删除
</code></pre><h3>索引</h3><pre><code class="language-sql">CREATE INDEX IF NOT EXISTS my_table_hash_index USING HASH(k);
DROP INDEX IF EXISTS my_table_hash_index;
</code></pre><h3>插入</h3><pre><code class="language-sql">INSERT INTO my_table (k, v) VALUES (&#x27;k&#x27;, &#x27;v&#x27;); -- 插入单条
INSERT INTO my_table (SELECT * FROM same_table); -- 相同结构表之间的批量插入
INSERT INTO my_table (k, v) (SELECT k, v FROM other_table); -- 不同结构表之间的批量插入
</code></pre><h3>更新</h3><pre><code class="language-sql">UPDATE my_table SET v = &#x27;new_v&#x27; WHERE k = &#x27;new_k&#x27;; -- 更新一次
UPDATE my_table AS o SET v = new_table.v FROM (SELECT * FROM other_table) as new_table WHERE o.k = new_table.k; -- 批量更新
</code></pre>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[redis 整理]]></title>
        <id>redis 整理</id>
        <link href="https://czasg.github.io/docusaurus/blog/2022/1/18/redis 整理"/>
        <updated>2022-01-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[整理下 redis 常见知识点。]]></summary>
        <content type="html"><![CDATA[<p>整理下 redis 常见知识点。</p><p>:::note redis 单线程理解
在 6.0 版本之前，redis 内部的网络IO和键值对的读写是在同一个线程中完成的。<br/>
<!-- -->但类似数据持久化、主从同步等，都是多线程完成的。所以本质上，redis 并不是一个绝对的单线程服务。
而官方之所以这样描述，也只是因为他的核心逻辑都是单线程实现的，然后还能提供这么高的并发，整体听上去就很牛了。</p><p>在 6.0 版本之后，redis 在网络IO部分引入了多线程，而键值对的读写则还是由单线程完成。  </p><p>:::</p><h2>常见数据类型</h2><ul><li>string</li><li>hash</li><li>list</li><li>set</li><li>zset</li><li>bitmap</li><li>hyperloglog</li><li>geo</li></ul><h2></h2>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx 配置说明]]></title>
        <id>nginx 配置说明</id>
        <link href="https://czasg.github.io/docusaurus/blog/2022/1/12/nginx配置说明"/>
        <updated>2022-01-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录一下 nginx 常见配置说明和部署模板（docker、k8s）。]]></summary>
        <content type="html"><![CDATA[<p>记录一下 nginx 常见配置说明和部署模板（docker、k8s）。</p><p>nginx 是一个高性能的 web 服务器，同时也能提供负载均衡和反向代理服务。</p><h2>nginx 常用指令</h2><ul><li>-c：用于指定一个配置文件</li><li>-t：用于测试配置是否可用</li><li>-s：用于发送信号，包括：stop, quit, reopen, reload。eg：<code>nginx -s reload</code></li></ul><pre><code class="language-shell" metastring="script title=&quot;指定并测试配置文件是否正确&quot;" title="&quot;指定并测试配置文件是否正确&quot;">nginx -t -c ./nginx.conf
</code></pre><h2>nginx 核心模块</h2><p>nginx 的核心模块主要有三个：</p><ul><li>主模块：管理 nginx 基本功能的模块</li><li>事件模块：管理 nginx 处理连接请求的模块</li><li>HTTP 模块：管理 nginx 处理 http 请求的模块</li></ul><h3>主模块</h3><pre><code class="language-text">user  nginx;  # 用户
pid  /var/run/nginx.pid;  # 进程ID
worker_processes  auto;  # 工作进程，可以指定具体数字
error_log  /var/log/nginx/error.log notice;  # 指定日志和错误级别，包含：debug、info、notice、warn、error、crit

worker_cpu_affinity  none;  # 用于绑定 worker 进程与 cpu
</code></pre><h3>事件模块</h3><pre><code class="language-text">events {
    worker_connections  1024;  # 每个工作进程最大链接数。乘以 worker_processes 就是该 nginx 服务的最大连接数
}
</code></pre><h3>HTTP 模块</h3><h4>location 路由匹配规则及顺序</h4><ul><li><code>=</code>: 精确匹配</li><li><code>^~</code>: 优先前缀匹配</li><li><code>~</code>: 正则匹配，区分大小写</li><li><code>~*</code>: 正则匹配，不区分大小写</li><li><code>!~</code>: 正则匹配，区分大小写</li><li><code>!~*</code>: 正则匹配，不区分大小写</li><li><code>/route</code>: 普通前缀匹配</li><li><code>/</code>: 通用匹配</li></ul><blockquote><p>精确匹配 &gt; 优先前缀匹配 &gt; 正则匹配 &gt; 普通前缀匹配 &gt; 通用匹配</p></blockquote><pre><code class="language-text">http {
    server {
        # 优先匹配依次往下
        location = /route { return 200; }
        location ^~ /route { return 201; }
        location ~ ^/route { return 202; }
        location /route { return 203; }
        location / { return 204; }
    }
}
</code></pre><h4>upstream 负载均衡策略</h4><ul><li>轮询：在每个服务之间轮询请求</li><li>weight：按指定权重比例在服务之间请求，默认 weight 为 1</li><li>ip_hash：按照请求 IP 计算 Hash，保证每次请求都访问同一个服务</li><li>fair：按照后端的响应时间来分配（三方插件实现）</li></ul><pre><code class="language-text">http {
    # 负载均衡
    upstream serverName {
        # ip_hash;  # 指定 ip_hash 负载均衡策略
        server 10.251.10.10:8080 weight=2;  # 指定权重比例
        server 10.251.10.10:8081 down;  # down 表示服务下线
        server 10.251.10.10:8082;
        server 10.251.10.10:8083 backup;  # backup 表示备用，当其他机器 down 或者压力比较大时，流量会走到此服务
        # fair;  # 指定 fair 负载均衡策略
    }

    server {
        listen  80;  # 监听端口
        server_name  _;  # 不启用域名检测

        location / {
            proxy_pass  http://serverName;  # 指定 upstream 名字即可
        }
    }
}
</code></pre><h4>http 客户端与服务端参数配置</h4><pre><code class="language-text">http {
    server {
        client_body_timeout  60s;  # 定义读取客户端请求体的超时
        client_body_buffer_size  8k;  # 设置读取客户端请求体的缓冲区大小（超过则存储到临时文件中）
        client_header_timeout  60s;  # 定义读取客户端请求头的超时
        client_header_buffer_size  1k;  # 设置读取客户端请求头的缓冲区大小
        client_max_body_size  0;  # 数据最大传输限制
        proxy_request_buffering  off;  # 默认开启，作用是缓冲请求。关闭后请求会立即转发到后端服务
        proxy_buffering  off;  # 对代理服务器的响应内容缓冲
        proxy_buffer_size  4k;  # 从代理服务器获取部分响应后进行缓冲
        proxy_buffers  8 4k;  # 从被代理的后端服务器取得的响应内容，会缓冲到这里
        proxy_connect_timeout  60s;  # 与后端服务建立连接的超时时间
        proxy_send_timeout  60s;  # 向后端传输请求的超时时间
        proxy_read_timeout  60s;  # 从后端读取响应的超时时间
        proxy_set_header  Host $proxy_host;

        proxy_set_header  Host $proxy_host;

        location / {
            proxy_set_header  Auth &quot;auth-key&quot;;
            proxy_pass  http://serverName;
        }
    }
}
</code></pre><pre><code class="language-text">http {
    server {
        location /index {
            index  index.html;  # 首页，即未指定后续路径时，匹配首页
        }
        location /try_files {
            root  /static
            try_files  $uri index.html;  # 依次尝试。/try_files/file -&gt; /try_files/static/file
        }
        location /alias/ {
            alias  /a/new/route/;  # 请求路径 /alias/files 等效于 /a/new/route/files，会替换掉匹配路由
        }
        location /root {
            root  /a/new/route/;  # 请求路径 /root/files 等效于 /a/new/route/root/files，会保留匹配路由
            # proxy_pass  http://serverName/;  # /root/index.html -&gt; http://serverName/index.html
            # proxy_pass  http://serverName;  # /root/index.html -&gt; http://serverName/root/index.html
        }
        location /rewrite {
            rewrite  ^/rewrite/permanent/(.*) http://serverName/$1 permanent;  # 301 永久重定向
            rewrite  ^/rewrite/redirect/(.*) http://serverName/$1 redirect;  # 302 临时重定向
            rewrite  ^/rewrite/last/(.*) http://serverName/$1 last;  # 实现重定向
            rewrite  ^/rewrite/break/(.*) http://serverName/$1 break;  # 实现重定向
        }
    }
}
</code></pre><h4>mirror</h4><pre><code class="language-text">http {
    server {
        location /mirror {
            mirror  /internal;  # mirror 实现流量拷贝
            proxy_pass  http://serverName;
        }

        location /internal {
            internal;  # 表示仅被内部请求发现
            proxy_pass  http://serverName;  # 指定 upstream 名字即可
        }
    }
}
</code></pre><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于 gRPC 实现负载均衡]]></title>
        <id>基于 gRPC 实现负载均衡</id>
        <link href="https://czasg.github.io/docusaurus/blog/2021/12/13/gRPC负载均衡"/>
        <updated>2021-12-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[本文主要介绍在 k8s 环境下 gRPC 服务在实现负载均衡时遇到的问题和解决思路。]]></summary>
        <content type="html"><![CDATA[<p>本文主要介绍在 k8s 环境下 gRPC 服务在实现负载均衡时遇到的问题和解决思路。</p><h2>概述</h2><p>我们的 gRPC 应用最初使用 <code>DaemonSet</code> 类型的资源对象部署在 k8s 上。通过污点和容忍配置，使得单台 Node 节点不在部署其他 Pod 应用。
而该 gRPC 应用，则通过 <code>NodePort Service</code> 的方式对外暴露服务。</p><p>在这种场景下直接对外暴露固定 IP 提供服务，业务流量全部打到单台宿主机上，所以也不存在负载均衡的说法。</p><p>随着业务压力逐渐增大，单点提供的能力已逐渐达到极限，我们采用水平拓展的方式，部署了多台单节点服务。也算暂时抗住了压力。但随后的暴露的问题，也让我们被迫选择了重构。</p><p>:::note 为什么选择重构
业务持续拓展，引入多节点的问题也逐渐暴露出来，当前服务架构下，多节点之间的数据一致性完全不能保证，人工运维简直不要太恶心，无奈只能重构。这里我们不针对此展开。<br/>
<!-- -->:::</p><p>服务改造升级完毕后，完全兼容历史 gRPC 接口，在 k8s 的配置上也有部分改动，以前的 <code>DaemontSet</code> 资源变更为 <code>Deployment</code> 资源，而 <code>NodePort Service</code> 资源则变更为 <code>ClusterIP Service</code> 资源。
项目正式进入到了提测阶段。</p><p>功能上基本没有太大的问题，毕竟引用了相同的 gRPC 接口文件。</p><p>问题主要出现在了负载均衡上，在多副本的场景下，发生了严重的流量倾斜，具体表现就是某个副本的压力非常高，而其他副本的压力很小，进而导致服务整体异常。</p><p>:::tip 简单分析
gRPC 是基于 HTTP2.0 实现的长连接，且默认没有超时，这种长连接能够大量减少 TCP 连接管理所带来的开销，但也破坏了标准的连接级的负载均衡。因为连接已经建立且不断开，也无法再进一步负载均衡了。  </p><p>那么再回到上述场景，显然就是客户端与某个具体的服务建立了长连接，而连接又不会断开，从而导致了持续的流量倾斜问题。
:::</p><p>选择有效的 gRPC 负载均衡方案，是解决我们当前问题的核心。</p><p>具体解决的方法有多种，我们主要将其分为：  </p><ul><li>用户侧的负载均衡</li><li>服务侧的负载均衡</li></ul><h2>gRPC 负载均衡 - 用户侧</h2><p>用户侧的 gRPC 负载均衡，是通过 DNS，使用户解析出全部的 gRPC 服务地址，然后用户自己实现负载策略。
最简单的策略就是与每个服务建立 gRPC 连接，然后轮询访问，实现 rr 负载。</p><p><img src="client-load-balancer.png"/></p><p>该方案实施起来比较容易，但对于用户侧有一定的要求。如：</p><ul><li>安全方面，要考虑用户的可靠性。</li><li>更新策略，解析 DNS 虽有现成的方案，但是常规方案一般无法探知到后续新创建的服务，所以需要设计更新策略。</li></ul><h2>gRPC 负载均衡 - 服务侧</h2><p>服务侧的 gRPC 负载均衡，需要引入一个负载均衡代理，我们称之为 <code>Load Balancer</code>，
用户向 LB 发起 RPC 请求，然后由该 LB 将 RPC 分配到一个可用的后端服务器上，
由该服务器提供 gRPC 服务，并将负载情况报告给 LB，进一步补全 LB 的负载信息。
<img src="server-load-balancer.png"/></p><p>在该方案中，负载均衡由 LB 统一管理，有一定的实施难度。<br/>
<!-- -->除非能找到高 star 的开源项目，不然开发与运维就是一笔不小的投入。</p><h2>方案选择</h2><p>考虑到实施难度，我们选择了用户侧的负载均衡方式。</p><p>首先要解决 DNS 的解析与负载，这一块，官方已经封装了 gRPC SDK，故用户可以通过升级 SDK 实现该功能。问题就在如何检测更新这一块了。</p><p>解决的方案也有两种：<br/>
<!-- -->1、服务端实现：MaxConnectionAge<br/>
<!-- -->2、客户端实现：KubeResolver   </p><p>:::info MaxConnectionAge
MaxConnectionAge 是 gRPC 服务端的参数，用于指定长连接最大保持时间。<br/>
<!-- -->配置该参数会使得长连接变成“短”连接，故性能会有一定的降低。</p><p>该方案的原理是，通过定期释放连接，使得客户端重新解析 DNS 获取最新的服务地址。
:::</p><p>:::info KubeResolver
该方案的原理是通过监听 k8s 的 api 资源状态，实时获取 gRPC 服务资源信息，从而实现检测更新。
:::</p><p>综合考虑后，最终选择了 MaxConnectionAge 方案，因为此方案仅仅通过适配参数就可以完成预期功能，虽然略显僵硬，但实际上效果还不错。</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github 搭建 Docusaurus 站点]]></title>
        <id>Github 搭建 Docusaurus 站点</id>
        <link href="https://czasg.github.io/docusaurus/blog/2021/12/3/Github搭建Docusaurus站点"/>
        <updated>2021-12-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[1、新建 Github 仓库]]></summary>
        <content type="html"><![CDATA[<h2>1、新建 Github 仓库</h2><p>首先，登录<a href="https://github.com/new">Github仓库创建页面</a>，我们创建一个全新的空白仓库，项目名命名为 <code>testDocusaurus</code>。</p><p>然后通过 <code>git</code> 将仓库拉取到本地，至此，我们拥有了一个全新的空白仓库 <code>testDocusaurus</code>。  </p><p><img src="gitindex.png"/></p><h2>2、初始化 Docusaurus 项目</h2><blockquote><p><a href="https://docusaurus.io/zh-CN/docs/installation">Docusaurus项目初始化细节请参考官方文档</a></p></blockquote><p>进入到仓库 <code>testDocusaurus</code> 所在的空白目录，并在此目录打开终端界面。</p><p>为了更好的完成接下来的步骤，你可能需要预先安装<strong>nodejs</strong>。在此，假设你已经准备完毕。<br/>
<!-- -->那我们接下来通过以下指令初始化一个 <code>Docusaurus</code> 项目。</p><pre><code class="language-shell" metastring="script">&gt;&gt;&gt; npx create-docusaurus@latest website classic
...
...
Successfully created &quot;website&quot;.
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles your website into static files for production.

  npm run serve
    Serves the built website locally.

  npm deploy
    Publishes the website to GitHub pages.

We recommend that you begin by typing:

  cd website
  npm start

Happy building awesome websites!
</code></pre><p>该指令运行完后，会输出一些简单的运行指令，而且我们应该可以看到一个 <code>website</code> 的目录，我们先将里面的内容剪贴出来，放到我们空白仓库目录下面。</p><p>此时，我们按照提示，运行 <code>npm start</code> 指令，我们就可以运行此项目。</p><p>通常启动端口为3000，则默认路径为：http://localhost:3000/  </p><p><img src="websiteindex.png"/></p><h2>3、搭建 Github Actions</h2><blockquote><p>Github Actions部署细节参考<a href="https://docusaurus.io/zh-CN/docs/deployment#deploying-to-github-pages">官方文档</a></p></blockquote><p>接入 <code>Github Actions</code> 需要创建一对新的 <strong>SSH Key</strong>，并将公钥和密钥均配置到 Github，我们来具体看下操作。</p><p>首先创建密钥，我们可以指定一个新的目录，然后得到公钥（id_rsa.pub）和私钥（id_rsa）</p><pre><code class="language-shell" metastring="script">&gt;&gt;&gt; ssh-keygen -t rsa -C &quot;email&quot;
...
...
The key&#x27;s randomart image is:
+---[RSA 3072]----+
| .=oo*=o=o.      |
| o+.=o==.o       |
|  .O.O=+o        |
|  ..=o@.oo       |
| . o +.+S+..     |
|  . + . E.o      |
|   o . .         |
|  .              |
|                 |
+----[SHA256]-----+
</code></pre><p>我们打开仓库的 <code>deploy keys</code>，选择新增，将 <code>id_rsa.pub</code> 中的内容复制进去，并选中 <code>Allow write access</code> 框，表示赋予部署写权限。
<img src="deploykey.png"/></p><p>此时部署公钥已经完成，我们再将私钥也配置上。打开同级配置下的 Secret，选择新增密钥，
我们将私钥内容复制到 <code>Value</code> 中，而 <code>Name</code> 填写 <code>GH_PAGES_DEPLOY</code> 即可。</p><p>最后，我们创建 <code>Github Actions</code>，将模板复制进去，则整个流水线就已经配置好了。复制时，将对应的基础配置改下即可，如下：</p><pre><code class="language-shell" metastring="script">git config --global user.email &quot;email&quot;
git config --global user.name &quot;name&quot;
</code></pre><p>这里的 <code>email</code> 需要是 github 配置的 email，而 <code>name</code> 则是 github 用户名。</p><h2>4、更新仓库，尝试自动部署</h2><p>确保 Github Pages 已经初始化好，那么我们往仓库推送修改时，就可以触发自动部署了。</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scrapy 源码学习]]></title>
        <id>Scrapy 源码学习</id>
        <link href="https://czasg.github.io/docusaurus/blog/2020/2/24/scrapy 源码学习"/>
        <updated>2020-02-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Scrapy 源码学习]]></summary>
        <content type="html"><![CDATA[<p>Scrapy 源码学习</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式爬虫调度设计]]></title>
        <id>分布式爬虫调度设计</id>
        <link href="https://czasg.github.io/docusaurus/blog/2020/2/24/分布式爬虫调度设计"/>
        <updated>2020-02-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[分布式爬虫调度设计]]></summary>
        <content type="html"><![CDATA[<p>分布式爬虫调度设计</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树遍历]]></title>
        <id>二叉树遍历</id>
        <link href="https://czasg.github.io/docusaurus/blog/2020/2/22/二叉树遍历"/>
        <updated>2020-02-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[二叉树遍历]]></summary>
        <content type="html"><![CDATA[<p>二叉树遍历</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库事务]]></title>
        <id>数据库事务</id>
        <link href="https://czasg.github.io/docusaurus/blog/2020/2/22/数据库事务"/>
        <updated>2020-02-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[数据库事务]]></summary>
        <content type="html"><![CDATA[<p>数据库事务</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 内存管理]]></title>
        <id>Python 内存管理</id>
        <link href="https://czasg.github.io/docusaurus/blog/2020/2/21/python 内存管理"/>
        <updated>2020-02-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Python 内存管理]]></summary>
        <content type="html"><![CDATA[<p>Python 内存管理</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux Namespace]]></title>
        <id>Linux Namespace</id>
        <link href="https://czasg.github.io/docusaurus/blog/2019/8/5/Linux Namespace"/>
        <updated>2019-08-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[namespace]]></summary>
        <content type="html"><![CDATA[<p>namespace</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scrapy 爬虫框架学习]]></title>
        <id>Scrapy 爬虫框架学习</id>
        <link href="https://czasg.github.io/docusaurus/blog/2019/5/13/scrapy 爬虫框架学习"/>
        <updated>2019-05-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[scrapy 框架的使用]]></summary>
        <content type="html"><![CDATA[<p>scrapy 框架的使用</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Selenium 学习]]></title>
        <id>Selenium 学习</id>
        <link href="https://czasg.github.io/docusaurus/blog/2019/4/26/selenium 学习"/>
        <updated>2019-04-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[selenium 使用]]></summary>
        <content type="html"><![CDATA[<p>selenium 使用</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 常用指令]]></title>
        <id>Linux 常用指令</id>
        <link href="https://czasg.github.io/docusaurus/blog/2019/3/2/Linux常用指令"/>
        <updated>2019-03-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[从使用维度划分 Linux 常用指令，便于梳理和总结。]]></summary>
        <content type="html"><![CDATA[<p>从使用维度划分 Linux 常用指令，便于梳理和总结。</p><ul><li>帮助指令</li><li>用户管理</li><li>文件管理</li><li>磁盘管理</li><li>进程管理</li><li>网络管理</li></ul><h2>帮助指令</h2><pre><code class="language-shell" metastring="script title=&quot;获取帮助&quot;" title="&quot;获取帮助&quot;">&gt;&gt;&gt; man ls
</code></pre><pre><code class="language-shell" metastring="script title=&quot;获取帮助&quot;" title="&quot;获取帮助&quot;">&gt;&gt;&gt; ls --help
</code></pre><h2>用户管理</h2><pre><code class="language-shell" metastring="script title=&quot;新增用户，ubuntu 下该指令无需 passwd 设置密码&quot;" title="&quot;新增用户，ubuntu">&gt;&gt;&gt; adduser cza
</code></pre><pre><code class="language-shell" metastring="script title=&quot;切换用户&quot;" title="&quot;切换用户&quot;">&gt;&gt;&gt; su root
</code></pre><h3>sshkey-gen</h3><h2>文件管理</h2><h3>rm &amp; cp</h3><ul><li>rm -r：递归执行操作，操作对象可以是目录</li><li>rm -f：（--force）强制执行删除且忽略文件不存在等错误</li><li>cp -r：递归复制</li></ul><pre><code class="language-shell" metastring="script title=&quot;创建和删除文件&quot;" title="&quot;创建和删除文件&quot;">rm -rf              // 递归删除
cp -r               // 递归复制
</code></pre><h3>wc</h3><p><code>wc</code> 用于计算统计，默认统计文件中的行、字、大小</p><ul><li>-l：计算行数</li><li>-w：计算字数</li><li>-c：计算bytes</li></ul><pre><code class="language-shell" metastring="script title=&quot;查看文件&quot;" title="&quot;查看文件&quot;">&gt;&gt;&gt; wc test.txt              // 输出文件行数、字数、大小
1  4 17 test.txt
&gt;&gt;&gt; ls | wc -l               // 统计文件数量
&gt;&gt;&gt; ls | cat -n              // 显示文件，并给每一个增加一个编号
</code></pre><h3>find</h3><p><code>find</code> 用于查找文件</p><ul><li>-type：指定查找类型<ul><li>f：文件</li><li>d：目录</li></ul></li><li>-name：指定查找名字</li><li>-delete：找到文件后执行删除</li></ul><pre><code class="language-shell" metastring="script title=&quot;查找文件&quot;" title="&quot;查找文件&quot;">find ./path -type f -name &quot;file_name&quot;
</code></pre><pre><code class="language-shell" metastring="script title=&quot;查找当前目录下全部文件并统计数量&quot;" title="&quot;查找当前目录下全部文件并统计数量&quot;">find ./ -type f | wc -l
</code></pre><pre><code class="language-shell" metastring="script title=&quot;查找到 tmp 结尾的文件并删除&quot;" title="&quot;查找到">find ./ -type f -name &quot;*.tmp&quot; -delete
</code></pre><h3>chmod</h3><p><code>chmod</code> 修改文件读、写、执行权限。一个文件的调用权限可以分为 user、group、other 三级。</p><p>针对用户执行</p><ul><li>u：文件所有者</li><li>g：文件所有者组</li><li>o：其他所有用户</li><li>a：所有用户</li><li>-R：递归执行当前目录所有文件</li></ul><pre><code class="language-shell" metastring="script title=&quot;修改文件权限&quot;" title="&quot;修改文件权限&quot;">&gt;&gt;&gt; chmod u+r test.txt
&gt;&gt;&gt; chmod g-r test.txt
&gt;&gt;&gt; chmod o=r test.txt
&gt;&gt;&gt; chmod a+r test.txt
</code></pre><pre><code class="language-shell" metastring="script title=&quot;修改文件权限&quot;" title="&quot;修改文件权限&quot;">chmod -R 777 test.txt    // 4（读r）2（写w）1（执行x），此时每个数据对应 u、g、o 的权限
</code></pre><h3>ln</h3><p><code>ln</code> 文件 软/硬 链接</p><ul><li>-s：软链接，仅生成一个镜像，不占用额外的磁盘空间（仅一个指针空间）。否则生成一个和源一样的文件，二者均实时保持同步。</li></ul><pre><code class="language-shell" metastring="script">ln -s old new       // 符号软链接
ln old new          // 符号软链接
</code></pre><h3>xargs</h3><p><code>xargs</code> 是一个命名行参数生成器，可以将其他管道传递过来的数据作为参数执行命名行，其默认执行指令是 echo</p><pre><code class="language-shell" metastring="script title=&quot;多行文本转单行&quot;" title="&quot;多行文本转单行&quot;">cat filename | xargs
</code></pre><pre><code class="language-shell" metastring="script title=&quot;统计源码文件行数&quot;" title="&quot;统计源码文件行数&quot;">find . -type f -name &quot;*.py&quot; -print0 | xargs -0 wc -l
</code></pre><pre><code class="language-shell" metastring="script title=&quot;查找并压缩目标文件&quot;" title="&quot;查找并压缩目标文件&quot;">find . -type f -name &quot;*.jpg&quot; | xargs tar -czvf images.tar.gz
</code></pre><pre><code class="language-shell" metastring="script title=&quot;下载文件&quot;" title="&quot;下载文件&quot;">cat url-list.txt | xargs wget -c
</code></pre><h3>grep</h3><p><code>grep</code> 用于查找文件中符合条件的字符串</p><ul><li>-n：计算并显示行号</li></ul><h3>sort 排序</h3><ul><li>-n 按数字进行排序 </li><li>-d 按字典序进行排序</li><li>-r 逆序排序</li><li>-k N 指定按第N列排序</li></ul><pre><code class="language-shell" metastring="script">sort -nrk 1 data.txt
sort -bd data                // 忽略像空格之类的前导空白字符

sort unsort.txt | uniq       // 消除重复行
sort unsort.txt | uniq -c    // 统计各行出现次数
sort unsort.txt | uniq -d    // 找出重复行
</code></pre><h3>tr 转化</h3><p><code>cat test.txt | tr a-z A-z</code></p><h3>cut 切割</h3><p><code>cut</code> 用于显示每行从头开始算起的字符</p><ul><li>-b：以字节为单位进行切割</li><li>-c：以字符为单位进行切割</li><li>-d：自定义分隔符，默认为制表符</li></ul><h2>磁盘管理</h2><h3>df</h3><p><code>df</code> 用于查看当前系统磁盘使用率  </p><ul><li>-h：优化显示</li></ul><h3>du</h3><p><code>du</code> 用于查看当前目录占用磁盘率</p><ul><li>-h：优化显示</li></ul><h3>tar</h3><p><code>tar</code> 用于压缩和解压</p><ul><li>-z：（--gzip）使用 zgip 来压缩或者解压</li><li>-x：（--extract）解压</li><li>-c：（--create）打包</li><li>-v：（--verbose）显示执行过程，具体操作的文件</li><li>-f：（--file）指定备份文件名</li></ul><pre><code class="language-shell" metastring="script title=&quot;压缩文件&quot;" title="&quot;压缩文件&quot;">tar -cvf 压缩文件.zip 单个文件或者目录
tar -zcvf gzip压缩文件.tar.gz 单个文件或者目录
</code></pre><h3>zip</h3><p>:::note linux 安装 zip
centos：
:::</p><h3>rar</h3><p>:::note linux 安装 rar
centos：
:::</p><h2>进程管理</h2><h3>ps</h3><p><code>ps</code> 用于查看 linux 下的进程状态，即 Process Status</p><pre><code class="language-shell" metastring="script title=&quot;显示所有命名及其CMD&quot;" title="&quot;显示所有命名及其CMD&quot;">ps -ef
ps -aux
</code></pre><h3>top</h3><p><code>top</code> 用于实时输出进程的状态信息</p><ul><li>-p：仅展示目标进程信息</li></ul><h3>kill</h3><p><code>kill</code> 用于杀掉一个进程，如：<code>kill -9 pid</code></p><ul><li>-l：显示信号</li><li>-9：（SIGKILL）杀掉进程</li><li>-15：（SIGTERM）正常停止一个进程</li></ul><pre><code class="language-text"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
</code></pre><h2>网络管理</h2><h3>dig</h3><p><code>dig</code> 用于查询域名映射的 DNS</p><p>:::note
centos: yum install -y bind-utils
:::</p><h3>netstat</h3><p><code>netstat</code> 用于显示网络状态</p><ul><li>-a：显示所有连线中的 socket</li><li>-l：显示监控中的 socket</li></ul><p>:::note linux 安装 netstat
centos：yum install -y net-tools
:::</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《即兴演讲》]]></title>
        <id>《即兴演讲》</id>
        <link href="https://czasg.github.io/docusaurus/blog/2019/1/14/即兴演讲"/>
        <updated>2019-01-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[说话无逻辑，说的就是我自己了吧🤣]]></summary>
        <content type="html"><![CDATA[<p>说话无逻辑，说的就是我自己了吧🤣<br/>
<!-- -->看看还有没有救🧐</p><blockquote><p>你需要做好准备，才能自然应对。一次优秀的即兴演讲，永远不是不经思考、随心所欲就脱口而出的。</p></blockquote><h2>思维模式</h2><p>正确的思维模式：</p><ul><li>领导意识</li><li>倾听</li><li>真实</li><li>专注</li><li>尊重</li></ul><p>保持真实：</p><ul><li>处于当下</li><li>分享想法</li><li>分享信念和价值观</li><li>分享感受</li><li>分享脆肉</li><li>分享故事</li></ul><p>保持专注：</p><ul><li>保持与谈话对象的专注，需要做到主题明确和重点突出</li></ul><p>保持尊重</p><ul><li>任何场景，尊重别人，尊重自己</li></ul><p>一般性的知识
经验性的知识</p><p>抓手：抓取注意力
要点：观点
结构体：论述
呼吁行动：</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
</feed>