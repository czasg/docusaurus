<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://czasg.github.io/docusaurus/blog</id>
    <title>Czasg Blog</title>
    <updated>2021-12-13T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://czasg.github.io/docusaurus/blog"/>
    <subtitle>Czasg Blog</subtitle>
    <icon>https://czasg.github.io/docusaurus/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[基于 gRPC 实现负载均衡]]></title>
        <id>基于 gRPC 实现负载均衡</id>
        <link href="https://czasg.github.io/docusaurus/blog/2021/12/13/gRPC负载均衡"/>
        <updated>2021-12-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[本文主要介绍在 k8s 环境下 gRPC 服务在实现负载均衡时遇到的问题和解决思路。]]></summary>
        <content type="html"><![CDATA[<p>本文主要介绍在 k8s 环境下 gRPC 服务在实现负载均衡时遇到的问题和解决思路。</p><h2>概述</h2><p>我们的 gRPC 应用最初使用 <code>DaemonSet</code> 类型的资源对象部署在 k8s 上。通过污点和容忍配置，使得单台 Node 节点不在部署其他 Pod 应用。
而该 gRPC 应用，则通过 <code>NodePort Service</code> 的方式对外暴露服务。</p><p>在这种场景下直接对外暴露固定 IP 提供服务，业务流量全部打到单台宿主机上，所以也不存在负载均衡的说法。</p><p>随着业务压力逐渐增大，单点提供的能力已逐渐达到极限，我们采用水平拓展的方式，部署了多台单节点服务。也算暂时抗住了压力。但随后的暴露的问题，也让我们被迫选择了重构。</p><p>:::note 为什么选择重构
业务持续拓展，引入多节点的问题也逐渐暴露出来，当前服务架构下，多节点之间的数据一致性完全不能保证，人工运维简直不要太恶心，无奈只能重构。这里我们不针对此展开。<br/>
<!-- -->:::</p><p>服务改造升级完毕后，完全兼容历史 gRPC 接口，在 k8s 的配置上也有部分改动，以前的 <code>DaemontSet</code> 资源变更为 <code>Deployment</code> 资源，而 <code>NodePort Service</code> 资源则变更为 <code>ClusterIP Service</code> 资源。
项目正式进入到了提测阶段。</p><p>功能上基本没有太大的问题，毕竟引用了相同的 gRPC 接口文件。</p><p>问题主要出现在了负载均衡上，在多副本的场景下，发生了严重的流量倾斜，具体表现就是某个副本的压力非常高，而其他副本的压力很小，进而导致服务整体异常。</p><p>:::tip 简单分析
gRPC 是基于 HTTP2.0 实现的长连接，且默认没有超时，这种长连接能够大量减少 TCP 连接管理所带来的开销，但也破坏了标准的连接级的负载均衡。因为连接已经建立且不断开，也无法再进一步负载均衡了。  </p><p>那么再回到上述场景，显然就是客户端与某个具体的服务建立了长连接，而连接又不会断开，从而导致了持续的流量倾斜问题。
:::</p><p>选择有效的 gRPC 负载均衡方案，是解决我们当前问题的核心。</p><p>具体解决的方法有多种，我们主要将其分为：  </p><ul><li>用户侧的负载均衡</li><li>服务侧的负载均衡</li></ul><h2>gRPC 负载均衡 - 用户侧</h2><p>用户侧的 gRPC 负载均衡，是通过 DNS，使用户解析出全部的 gRPC 服务地址，然后用户自己实现负载策略。
最简单的策略就是与每个服务建立 gRPC 连接，然后轮询访问，实现 rr 负载。</p><p><img src="client-load-balancer.png"/></p><p>该方案实施起来比较容易，但对于用户侧有一定的要求。如：</p><ul><li>安全方面，要考虑用户的可靠性。</li><li>更新策略，解析 DNS 虽有现成的方案，但是常规方案一般无法探知到后续新创建的服务，所以需要设计更新策略。</li></ul><h2>gRPC 负载均衡 - 服务侧</h2><p>服务侧的 gRPC 负载均衡，需要引入一个负载均衡代理，我们称之为 <code>Load Balancer</code>，
用户向 LB 发起 RPC 请求，然后由该 LB 将 RPC 分配到一个可用的后端服务器上，
由该服务器提供 gRPC 服务，并将负载情况报告给 LB，进一步补全 LB 的负载信息。
<img src="server-load-balancer.png"/></p><p>在该方案中，负载均衡由 LB 统一管理，有一定的实施难度。<br/>
<!-- -->除非能找到高 star 的开源项目，不然开发与运维就是一笔不小的投入。</p><h2>方案选择</h2><p>考虑到实施难度，我们选择了用户侧的负载均衡方式。</p><p>首先要解决 DNS 的解析与负载，这一块，官方已经封装了 gRPC SDK，故用户可以通过升级 SDK 实现该功能。问题就在如何检测更新这一块了。</p><p>解决的方案也有两种：<br/>
<!-- -->1、服务端实现：MaxConnectionAge<br/>
<!-- -->2、客户端实现：KubeResolver   </p><p>:::info MaxConnectionAge
MaxConnectionAge 是 gRPC 服务端的参数，用于指定长连接最大保持时间。<br/>
<!-- -->配置该参数会使得长连接变成“短”连接，故性能会有一定的降低。</p><p>该方案的原理是，通过定期释放连接，使得客户端重新解析 DNS 获取最新的服务地址。
:::</p><p>:::info KubeResolver
该方案的原理是通过监听 k8s 的 api 资源状态，实时获取 gRPC 服务资源信息，从而实现检测更新。
:::</p><p>综合考虑后，最终选择了 MaxConnectionAge 方案，因为此方案仅仅通过适配参数就可以完成预期功能，虽然略显僵硬，但实际上效果还不错。</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github 搭建 Docusaurus 站点]]></title>
        <id>Github 搭建 Docusaurus 站点</id>
        <link href="https://czasg.github.io/docusaurus/blog/2021/12/3/Github搭建Docusaurus站点"/>
        <updated>2021-12-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[1、新建 Github 仓库]]></summary>
        <content type="html"><![CDATA[<h2>1、新建 Github 仓库</h2><p>首先，登录<a href="https://github.com/new">Github仓库创建页面</a>，我们创建一个全新的空白仓库，项目名命名为 <code>testDocusaurus</code>。</p><p>然后通过 <code>git</code> 将仓库拉取到本地，至此，我们拥有了一个全新的空白仓库 <code>testDocusaurus</code>。  </p><p><img src="gitindex.png"/></p><h2>2、初始化 Docusaurus 项目</h2><blockquote><p><a href="https://docusaurus.io/zh-CN/docs/installation">Docusaurus项目初始化细节请参考官方文档</a></p></blockquote><p>进入到仓库 <code>testDocusaurus</code> 所在的空白目录，并在此目录打开终端界面。</p><p>为了更好的完成接下来的步骤，你可能需要预先安装<strong>nodejs</strong>。在此，假设你已经准备完毕。<br/>
<!-- -->那我们接下来通过以下指令初始化一个 <code>Docusaurus</code> 项目。</p><pre><code class="language-shell" metastring="script">&gt;&gt;&gt; npx create-docusaurus@latest website classic
...
...
Successfully created &quot;website&quot;.
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles your website into static files for production.

  npm run serve
    Serves the built website locally.

  npm deploy
    Publishes the website to GitHub pages.

We recommend that you begin by typing:

  cd website
  npm start

Happy building awesome websites!
</code></pre><p>该指令运行完后，会输出一些简单的运行指令，而且我们应该可以看到一个 <code>website</code> 的目录，我们先将里面的内容剪贴出来，放到我们空白仓库目录下面。</p><p>此时，我们按照提示，运行 <code>npm start</code> 指令，我们就可以运行此项目。</p><p>通常启动端口为3000，则默认路径为：http://localhost:3000/  </p><p><img src="websiteindex.png"/></p><h2>3、搭建 Github Actions</h2><blockquote><p>Github Actions部署细节参考<a href="https://docusaurus.io/zh-CN/docs/deployment#deploying-to-github-pages">官方文档</a></p></blockquote><p>接入 <code>Github Actions</code> 需要创建一对新的 <strong>SSH Key</strong>，并将公钥和密钥均配置到 Github，我们来具体看下操作。</p><p>首先创建密钥，我们可以指定一个新的目录，然后得到公钥（id_rsa.pub）和私钥（id_rsa）</p><pre><code class="language-shell" metastring="script">&gt;&gt;&gt; ssh-keygen -t rsa -C &quot;email&quot;
...
...
The key&#x27;s randomart image is:
+---[RSA 3072]----+
| .=oo*=o=o.      |
| o+.=o==.o       |
|  .O.O=+o        |
|  ..=o@.oo       |
| . o +.+S+..     |
|  . + . E.o      |
|   o . .         |
|  .              |
|                 |
+----[SHA256]-----+
</code></pre><p>我们打开仓库的 <code>deploy keys</code>，选择新增，将 <code>id_rsa.pub</code> 中的内容复制进去，并选中 <code>Allow write access</code> 框，表示赋予部署写权限。
<img src="deploykey.png"/></p><p>此时部署公钥已经完成，我们再将私钥也配置上。打开同级配置下的 Secret，选择新增密钥，
我们将私钥内容复制到 <code>Value</code> 中，而 <code>Name</code> 填写 <code>GH_PAGES_DEPLOY</code> 即可。</p><p>最后，我们创建 <code>Github Actions</code>，将模板复制进去，则整个流水线就已经配置好了。复制时，将对应的基础配置改下即可，如下：</p><pre><code class="language-shell" metastring="script">git config --global user.email &quot;email&quot;
git config --global user.name &quot;name&quot;
</code></pre><p>这里的 <code>email</code> 需要是 github 配置的 email，而 <code>name</code> 则是 github 用户名。</p><h2>4、更新仓库，尝试自动部署</h2><p>确保 Github Pages 已经初始化好，那么我们往仓库推送修改时，就可以触发自动部署了。</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scrapy 源码学习]]></title>
        <id>Scrapy 源码学习</id>
        <link href="https://czasg.github.io/docusaurus/blog/2020/2/24/scrapy 源码学习"/>
        <updated>2020-02-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Scrapy 源码学习]]></summary>
        <content type="html"><![CDATA[<p>Scrapy 源码学习</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式爬虫调度设计]]></title>
        <id>分布式爬虫调度设计</id>
        <link href="https://czasg.github.io/docusaurus/blog/2020/2/24/分布式爬虫调度设计"/>
        <updated>2020-02-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[分布式爬虫调度设计]]></summary>
        <content type="html"><![CDATA[<p>分布式爬虫调度设计</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树遍历]]></title>
        <id>二叉树遍历</id>
        <link href="https://czasg.github.io/docusaurus/blog/2020/2/22/二叉树遍历"/>
        <updated>2020-02-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[二叉树遍历]]></summary>
        <content type="html"><![CDATA[<p>二叉树遍历</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库事务]]></title>
        <id>数据库事务</id>
        <link href="https://czasg.github.io/docusaurus/blog/2020/2/22/数据库事务"/>
        <updated>2020-02-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[数据库事务]]></summary>
        <content type="html"><![CDATA[<p>数据库事务</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 内存管理]]></title>
        <id>Python 内存管理</id>
        <link href="https://czasg.github.io/docusaurus/blog/2020/2/21/python 内存管理"/>
        <updated>2020-02-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Python 内存管理]]></summary>
        <content type="html"><![CDATA[<p>Python 内存管理</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux Namespace]]></title>
        <id>Linux Namespace</id>
        <link href="https://czasg.github.io/docusaurus/blog/2019/8/5/Linux Namespace"/>
        <updated>2019-08-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[namespace]]></summary>
        <content type="html"><![CDATA[<p>namespace</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scrapy 爬虫框架学习]]></title>
        <id>Scrapy 爬虫框架学习</id>
        <link href="https://czasg.github.io/docusaurus/blog/2019/5/13/scrapy 爬虫框架学习"/>
        <updated>2019-05-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[scrapy 框架的使用]]></summary>
        <content type="html"><![CDATA[<p>scrapy 框架的使用</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Selenium 学习]]></title>
        <id>Selenium 学习</id>
        <link href="https://czasg.github.io/docusaurus/blog/2019/4/26/selenium 学习"/>
        <updated>2019-04-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[selenium 使用]]></summary>
        <content type="html"><![CDATA[<p>selenium 使用</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 常用指令]]></title>
        <id>Linux 常用指令</id>
        <link href="https://czasg.github.io/docusaurus/blog/2019/3/2/Linux常用指令"/>
        <updated>2019-03-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[从使用维度划分 Linux 常用指令，便于梳理和总结。]]></summary>
        <content type="html"><![CDATA[<p>从使用维度划分 Linux 常用指令，便于梳理和总结。</p><ul><li>帮助指令</li><li>用户管理</li><li>文件管理</li><li>磁盘管理</li><li>进程管理</li><li>网络管理</li></ul><h2>帮助指令</h2><pre><code class="language-shell" metastring="script title=&quot;获取帮助&quot;" title="&quot;获取帮助&quot;">&gt;&gt;&gt; man ls
</code></pre><pre><code class="language-shell" metastring="script title=&quot;获取帮助&quot;" title="&quot;获取帮助&quot;">&gt;&gt;&gt; ls --help
</code></pre><h2>用户管理</h2><pre><code class="language-shell" metastring="script title=&quot;新增用户，ubuntu 下该指令无需 passwd 设置密码&quot;" title="&quot;新增用户，ubuntu">&gt;&gt;&gt; adduser cza
</code></pre><pre><code class="language-shell" metastring="script title=&quot;切换用户&quot;" title="&quot;切换用户&quot;">&gt;&gt;&gt; su root
</code></pre><h3>sshkey-gen</h3><h2>文件管理</h2><h3>rm &amp; cp</h3><ul><li>rm -r：递归执行操作，操作对象可以是目录</li><li>rm -f：（--force）强制执行删除且忽略文件不存在等错误</li><li>cp -r：递归复制</li></ul><pre><code class="language-shell" metastring="script title=&quot;创建和删除文件&quot;" title="&quot;创建和删除文件&quot;">rm -rf              // 递归删除
cp -r               // 递归复制
</code></pre><h3>wc</h3><p><code>wc</code> 用于计算统计，默认统计文件中的行、字、大小</p><ul><li>-l：计算行数</li><li>-w：计算字数</li><li>-c：计算bytes</li></ul><pre><code class="language-shell" metastring="script title=&quot;查看文件&quot;" title="&quot;查看文件&quot;">&gt;&gt;&gt; wc test.txt              // 输出文件行数、字数、大小
1  4 17 test.txt
&gt;&gt;&gt; ls | wc -l               // 统计文件数量
&gt;&gt;&gt; ls | cat -n              // 显示文件，并给每一个增加一个编号
</code></pre><h3>find</h3><p><code>find</code> 用于查找文件</p><ul><li>-type：指定查找类型<ul><li>f：文件</li><li>d：目录</li></ul></li><li>-name：指定查找名字</li><li>-delete：找到文件后执行删除</li></ul><pre><code class="language-shell" metastring="script title=&quot;查找文件&quot;" title="&quot;查找文件&quot;">find ./path -type f -name &quot;file_name&quot;
</code></pre><pre><code class="language-shell" metastring="script title=&quot;查找当前目录下全部文件并统计数量&quot;" title="&quot;查找当前目录下全部文件并统计数量&quot;">find ./ -type f | wc -l
</code></pre><pre><code class="language-shell" metastring="script title=&quot;查找到 tmp 结尾的文件并删除&quot;" title="&quot;查找到">find ./ -type f -name &quot;*.tmp&quot; -delete
</code></pre><h3>chmod</h3><p><code>chmod</code> 修改文件读、写、执行权限。一个文件的调用权限可以分为 user、group、other 三级。</p><p>针对用户执行</p><ul><li>u：文件所有者</li><li>g：文件所有者组</li><li>o：其他所有用户</li><li>a：所有用户</li><li>-R：递归执行当前目录所有文件</li></ul><pre><code class="language-shell" metastring="script title=&quot;修改文件权限&quot;" title="&quot;修改文件权限&quot;">&gt;&gt;&gt; chmod u+r test.txt
&gt;&gt;&gt; chmod g-r test.txt
&gt;&gt;&gt; chmod o=r test.txt
&gt;&gt;&gt; chmod a+r test.txt
</code></pre><pre><code class="language-shell" metastring="script title=&quot;修改文件权限&quot;" title="&quot;修改文件权限&quot;">chmod -R 777 test.txt    // 4（读r）2（写w）1（执行x），此时每个数据对应 u、g、o 的权限
</code></pre><h3>ln</h3><p><code>ln</code> 文件 软/硬 链接</p><ul><li>-s：软链接，仅生成一个镜像，不占用额外的磁盘空间（仅一个指针空间）。否则生成一个和源一样的文件，二者均实时保持同步。</li></ul><pre><code class="language-shell" metastring="script">ln -s old new       // 符号软链接
ln old new          // 符号软链接
</code></pre><h3>xargs</h3><p><code>xargs</code> 是一个命名行参数生成器，可以将其他管道传递过来的数据作为参数执行命名行，其默认执行指令是 echo</p><pre><code class="language-shell" metastring="script title=&quot;多行文本转单行&quot;" title="&quot;多行文本转单行&quot;">cat filename | xargs
</code></pre><pre><code class="language-shell" metastring="script title=&quot;统计源码文件行数&quot;" title="&quot;统计源码文件行数&quot;">find . -type f -name &quot;*.py&quot; -print0 | xargs -0 wc -l
</code></pre><pre><code class="language-shell" metastring="script title=&quot;查找并压缩目标文件&quot;" title="&quot;查找并压缩目标文件&quot;">find . -type f -name &quot;*.jpg&quot; | xargs tar -czvf images.tar.gz
</code></pre><pre><code class="language-shell" metastring="script title=&quot;下载文件&quot;" title="&quot;下载文件&quot;">cat url-list.txt | xargs wget -c
</code></pre><h3>grep</h3><p><code>grep</code> 用于查找文件中符合条件的字符串</p><ul><li>-n：计算并显示行号</li></ul><h3>sort 排序</h3><ul><li>-n 按数字进行排序 </li><li>-d 按字典序进行排序</li><li>-r 逆序排序</li><li>-k N 指定按第N列排序</li></ul><pre><code class="language-shell" metastring="script">sort -nrk 1 data.txt
sort -bd data                // 忽略像空格之类的前导空白字符

sort unsort.txt | uniq       // 消除重复行
sort unsort.txt | uniq -c    // 统计各行出现次数
sort unsort.txt | uniq -d    // 找出重复行
</code></pre><h3>tr 转化</h3><p><code>cat test.txt | tr a-z A-z</code></p><h3>cut 切割</h3><p><code>cut</code> 用于显示每行从头开始算起的字符</p><ul><li>-b：以字节为单位进行切割</li><li>-c：以字符为单位进行切割</li><li>-d：自定义分隔符，默认为制表符</li></ul><h2>磁盘管理</h2><h3>df</h3><p><code>df</code> 用于查看当前系统磁盘使用率  </p><ul><li>-h：优化显示</li></ul><h3>du</h3><p><code>du</code> 用于查看当前目录占用磁盘率</p><ul><li>-h：优化显示</li></ul><h3>tar</h3><p><code>tar</code> 用于压缩和解压</p><ul><li>-z：（--gzip）使用 zgip 来压缩或者解压</li><li>-x：（--extract）解压</li><li>-c：（--create）打包</li><li>-v：（--verbose）显示执行过程，具体操作的文件</li><li>-f：（--file）指定备份文件名</li></ul><pre><code class="language-shell" metastring="script title=&quot;压缩文件&quot;" title="&quot;压缩文件&quot;">tar -cvf 压缩文件.zip 单个文件或者目录
tar -zcvf gzip压缩文件.tar.gz 单个文件或者目录
</code></pre><h3>zip</h3><p>:::note linux 安装 zip
centos：
:::</p><h3>rar</h3><p>:::note linux 安装 rar
centos：
:::</p><h2>进程管理</h2><h3>ps</h3><p><code>ps</code> 用于查看 linux 下的进程状态，即 Process Status</p><pre><code class="language-shell" metastring="script title=&quot;显示所有命名及其CMD&quot;" title="&quot;显示所有命名及其CMD&quot;">ps -ef
ps -aux
</code></pre><h3>top</h3><p><code>top</code> 用于实时输出进程的状态信息</p><ul><li>-p：仅展示目标进程信息</li></ul><h3>kill</h3><p><code>kill</code> 用于杀掉一个进程，如：<code>kill -9 pid</code></p><ul><li>-l：显示信号</li><li>-9：（SIGKILL）杀掉进程</li><li>-15：（SIGTERM）正常停止一个进程</li></ul><pre><code class="language-text"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
</code></pre><h2>网络管理</h2><h3>dig</h3><p><code>dig</code> 用于查询域名映射的 DNS</p><p>:::note
centos: yum install -y bind-utils
:::</p><h3>netstat</h3><p><code>netstat</code> 用于显示网络状态</p><ul><li>-a：显示所有连线中的 socket</li><li>-l：显示监控中的 socket</li></ul><p>:::note linux 安装 netstat
centos：yum install -y net-tools
:::</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《即兴演讲》]]></title>
        <id>《即兴演讲》</id>
        <link href="https://czasg.github.io/docusaurus/blog/2019/1/14/即兴演讲"/>
        <updated>2019-01-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[说话无逻辑，说的就是我自己了吧🤣]]></summary>
        <content type="html"><![CDATA[<p>说话无逻辑，说的就是我自己了吧🤣<br/>
<!-- -->看看还有没有救🧐</p><blockquote><p>你需要做好准备，才能自然应对。一次优秀的即兴演讲，永远不是不经思考、随心所欲就脱口而出的。</p></blockquote><h2>思维模式</h2><p>正确的思维模式：</p><ul><li>领导意识</li><li>倾听</li><li>真实</li><li>专注</li><li>尊重</li></ul><p>保持真实：</p><ul><li>处于当下</li><li>分享想法</li><li>分享信念和价值观</li><li>分享感受</li><li>分享脆肉</li><li>分享故事</li></ul><p>保持专注：</p><ul><li>保持与谈话对象的专注，需要做到主题明确和重点突出</li></ul><p>保持尊重</p><ul><li>任何场景，尊重别人，尊重自己</li></ul><p>一般性的知识
经验性的知识</p><p>抓手：抓取注意力
要点：观点
结构体：论述
呼吁行动：</p><br/><p>:::info 👇👇👇
<strong>本文作者:</strong> Czasg<br/>
<strong>版权声明:</strong> 转载请注明出处哦~👮‍<br/>
<!-- -->:::</p>]]></content>
        <author>
            <name>Czasg</name>
            <uri>https://github.com/czasg</uri>
        </author>
    </entry>
</feed>